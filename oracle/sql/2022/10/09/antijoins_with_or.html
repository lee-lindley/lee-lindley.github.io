<!DOCTYPE html><html><head><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="shortcut icon" href="/static/img/favicon.ico" /><title>Tuning Query with OR Conditions in a NOT EXISTS - Lee Lindley Scratchpad</title><meta name="author" content="Lee Lindley" /><meta name="description" content="Tuning Query with OR Conditions in a NOT EXISTS" /><meta name="keywords" content="Tuning Query with OR Conditions in a NOT EXISTS, Lee Lindley Scratchpad, oracle, sql" /><link rel="alternate" type="application/rss+xml" title="RSS" href="/feed.xml"><meta content="" property="fb:app_id"><meta content="Lee Lindley Scratchpad" property="og:site_name"><meta content="Tuning Query with OR Conditions in a NOT EXISTS" property="og:title"><meta content="article" property="og:type"><meta content="Posts on Technical Subjects, mostly Oracle and Linux" property="og:description"><meta content="https://lee-lindley.github.io/oracle/sql/2022/10/09/antijoins_with_or.html" property="og:url"><meta content="2022-10-09T02:00:00-04:00" property="article:published_time"><meta content="https://lee-lindley.github.io/about/" property="article:author"><meta content="oracle" property="article:section"><meta content="oracle" property="article:tag"><meta content="sql" property="article:tag"><meta content="antijoin" property="article:tag"><meta name="twitter:card" content="summary"><meta name="twitter:site" content="@"><meta name="twitter:creator" content="@"><meta name="twitter:title" content="Tuning Query with OR Conditions in a NOT EXISTS"><meta name="twitter:url" content="https://lee-lindley.github.io/oracle/sql/2022/10/09/antijoins_with_or.html"><meta name="twitter:description" content="Posts on Technical Subjects, mostly Oracle and Linux"><link href="/static/css/font-awesome.min.css" rel="stylesheet" integrity="sha384-T8Gy5hrqNKT+hzMclPo118YTQO6cYprQmhrYwIiQ/3axmI1hQomh7Ud2hPOy8SP1" crossorigin="anonymous"><link rel="stylesheet" href="/static/css/syntax.css"><link href="/static/css/bootstrap.min.css" rel="stylesheet"><link href="https://fonts.googleapis.com/css?family=Roboto+Condensed:400,300italic,300,400italic,700&amp;subset=latin,latin-ext" rel="stylesheet" type="text/css"><link rel="stylesheet" href="/static/css/super-search.css"><link rel="stylesheet" href="/static/css/thickbox.css"><link rel="stylesheet" href="/static/css/projects.css"><link rel="stylesheet" href="/static/css/main.css"><body><div class="container"><div class="col-sm-3"><div class="fixed-condition"><h1 class="author-name"><a href="/">Lee Lindley</a></h1><div class="profile-about"> I'm Just Another Perl Hacker who wound up in a big Oracle Database playground</div><div class="social"><ul><li><a href="https://linkedin.com/in/lee-lindley" target="_blank"><i class="fa fa-linkedin"></i></a><li><a href="https://github.com/lee-lindley" target="_blank"><i class="fa fa-github"></i></a></ul></div><div class="search" id="js-search"> <input type="text" placeholder="(sitemap)~$ type to search" class="search__input form-control" id="js-search__input"><ul class="search__results" id="js-search__results"></ul></div><hr /><ul class="sidebar-nav"> <strong>Navigation</strong><li><a href="/">Home</a><li><a class="about" href="/about/">About Me</a><li><a class="about" href="/projects/">My Projects</a><li><a class="about" href="/feed.xml">XML Feed</a></ul></div></div><div class="col-sm-8 col-offset-1 main-layout"><header class="post-header"><h1 class="post-title">Tuning Query with OR Conditions in a NOT EXISTS</h1></header><span class="time">09 Oct 2022</span> <span class="categories"> &raquo; <a href="/category/oracle">oracle</a>, <a href="/category/sql">sql</a> </span><div class="content"><div class="post"><h1 id="introduction">Introduction</h1><p>While tuning an Oracle query provided by a business user I ran into a roadblock that confounded me. The query contained a <em>NOT EXISTS</em> clause against a large row set, one that was a Common Table Expression (CTE or WITH clause) that was relatively complex. The CTE plan was fine, but it resulted in about a million rows. An ideal plan to satisfy the <em>NOT EXISTS</em> from my perspective would use a <em>HASH JOIN ANTI</em> against that row set. That was not happening. It was doing a <em>FILTER</em> operation. I’m not 100% sure what Oracle is doing under the covers on the <em>FILTER</em>.<h1 id="problem">Problem</h1><p>The problem SQL is too complex and intertwined with my client’s business to reproduce here, but pseudo code is good enough for the discussion.<div class="language-plsql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kr">WITH</span> <span class="n">ne</span> <span class="kr">AS</span> <span class="p">(</span>
    <span class="kr">SELECT</span> 
        <span class="n">lookup_value</span> 
    <span class="kr">FROM</span> <span class="n">large_result_set</span> <span class="n">L</span>
    <span class="kr">WHERE</span> <span class="n">some_fancy_condition</span> <span class="o">=</span> <span class="o">'</span><span class="s1">TRUE</span><span class="o">'</span>
<span class="p">)</span>
<span class="kr">SELECT</span> <span class="c1">--+ cardinality(a 1000000)</span>
    <span class="n">my_key_value</span><span class="p">,</span> <span class="n">my_lookup_name</span><span class="p">,</span> <span class="n">column_list</span>
<span class="kr">FROM</span> <span class="n">another_large_result_set</span> <span class="n">a</span>
<span class="kr">WHERE</span> 
    <span class="c1">-- this is done using an index one by one which is ok</span>
    <span class="ow">NOT</span> <span class="kr">EXISTS</span> <span class="p">(</span>
        <span class="kr">SELECT</span> <span class="mi">1</span>
        <span class="kr">FROM</span> <span class="n">some_other_table</span> <span class="n">s</span>
        <span class="kr">WHERE</span> <span class="n">s</span><span class="p">.</span><span class="n">key_value</span> <span class="o">=</span> <span class="n">a</span><span class="p">.</span><span class="n">my_key_value</span>
    <span class="p">)</span>
    <span class="c1">-- below is the problem antijoin</span>
    <span class="ow">AND</span> <span class="ow">NOT</span> <span class="kr">EXISTS</span> <span class="p">(</span>
        <span class="kr">SELECT</span> <span class="mi">1</span>
        <span class="kr">FROM</span> <span class="n">ne</span>
        <span class="kr">WHERE</span> <span class="n">ne</span><span class="p">.</span><span class="n">lookup_name</span> <span class="o">=</span> <span class="n">a</span><span class="p">.</span><span class="n">my_lookup_name</span>
            <span class="c1">-- this DECODE represents an OR condition</span>
            <span class="ow">AND</span> <span class="nf">DECODE</span><span class="p">(</span><span class="n">ne</span><span class="p">.</span><span class="n">lookup_value</span><span class="p">,</span> <span class="o">'</span><span class="s1">*</span><span class="o">'</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">a</span><span class="p">.</span><span class="n">my_key_value</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="o">=</span> <span class="mi">1</span>
            <span class="cm">/* --I would prefer this syntax
                AND (ne.lookup_value = '*' OR ne.lookup_value = a.my_key_value)
            */</span>
    <span class="p">)</span>
</code></pre></div></div><p>The picture below (Toad tree view) from the actual plan shows a <em>FILTER</em> operation with 3 components - <em>another_large_result_set</em>, <em>some_other_table</em>, and <em>ne</em>. We can tell from the fact that it shows the index lookup, that it is doing a one by one index probe of <em>some_other_table</em>. Less obvious what it is doing with <em>ne</em>, but in the absence of other evidence, we must assume it is walking through the heap in memory looking for a match. Maybe it has sorted it and is doing something smarter than that, but it is not a hash.<table class="img-table-centered"><thead><tr><th style="text-align: center"><em>Figure 1 - Explain Plan of Filter Operation for Antijoin with OR</em><tbody><tr><td style="text-align: center"><img src="/images/hash_aj_or_1.png" alt="" /></table><p>Why could it not hash the <em>ne</em> row set and probe it with a <em>HASH JOIN ANTI</em>? Because you cannot hash an <em>OR</em> condition.<p>If it is a regular join instead of an anti-join that has this <em>OR</em> condition, the optimizer can break the problem into multiple <em>HASH JOIN</em>’s and do a <em>CONCATENATION</em> operation of the results for each of the <em>OR</em> conditions.<p>I do not recall seeing a plan where the optimizer chooses two separate <em>JOIN ANTI</em> operations in series. It would not be a <em>CONCATENATION</em> operation between them, but the opposite of that because they are anti-joins. I don’t think the Oracle optimizer has an operation for splitting an <em>JOIN ANTI</em> into two <em>JOIN ANTI</em>’s in sequence.<h1 id="solution">Solution</h1><p>I first thought maybe the <em>DECODE</em> function on the value, being a function, was confusing the optimizer. Rewriting that in my preferred syntax with an <em>OR</em> condition rather than the implied <em>OR</em> of the <em>DECODE</em> did not solve the issue. It was a long shot given my understanding of the optimizer, but I don’t know everything, the optimizer is constantly evolving, and I wanted to give it the best chance to solve the issue.<p>I’ve seen this before on regular joins with a similar construct of a lookup table having wild cards. In that case it was multiple conditions in the join with wild cards optional on all of them. The optimizer was overwhelmed and just did a giant filter as we saw with this anti-join. One would think it might be able to break the problem into multiple joins with concatenation, but the multiple join conditions seems to have exceeded the optimizer’s breadth of options.<p>I recall having to break the problem down into two separate joins manually, one for the wild card and one for the direct match of the key, at least for the first of multiple wild-carded join conditions. That at least was able to reduce the join set to one that could be filtered for the remaining conditions.<p>I tried a similar trick here rewriting the query as two separate <em>NOT EXISTS</em> with an <em>AND</em> condition between them.<div class="language-plsql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kr">WITH</span> <span class="n">ne</span> <span class="kr">AS</span> <span class="p">(</span>
    <span class="kr">SELECT</span> 
        <span class="n">lookup_value</span> 
    <span class="kr">FROM</span> <span class="n">large_result_set</span> <span class="n">L</span>
    <span class="kr">WHERE</span> <span class="n">some_fancy_condition</span> <span class="o">=</span> <span class="o">'</span><span class="s1">TRUE</span><span class="o">'</span>
<span class="p">)</span>
<span class="kr">SELECT</span> <span class="c1">--+ cardinality(a 1000000)</span>
    <span class="n">my_key_value</span><span class="p">,</span> <span class="n">my_lookup_name</span><span class="p">,</span> <span class="n">column_list</span>
<span class="kr">FROM</span> <span class="n">another_large_result_set</span> <span class="n">a</span>
<span class="kr">WHERE</span> 
    <span class="c1">-- this is done using an index one by one which is ok</span>
    <span class="ow">NOT</span> <span class="kr">EXISTS</span> <span class="p">(</span> <span class="c1">-- not exists 0</span>
        <span class="kr">SELECT</span> <span class="mi">1</span>
        <span class="kr">FROM</span> <span class="n">some_other_table</span> <span class="n">s</span>
        <span class="kr">WHERE</span> <span class="n">s</span><span class="p">.</span><span class="n">key_value</span> <span class="o">=</span> <span class="n">a</span><span class="p">.</span><span class="n">my_key_value</span>
    <span class="p">)</span>
    <span class="ow">AND</span> <span class="ow">NOT</span> <span class="kr">EXISTS</span> <span class="p">(</span> <span class="c1">-- not exists 1</span>
        <span class="kr">SELECT</span> <span class="mi">1</span>
        <span class="kr">FROM</span> <span class="n">ne</span>
        <span class="kr">WHERE</span> <span class="n">ne</span><span class="p">.</span><span class="n">lookup_name</span> <span class="o">=</span> <span class="n">a</span><span class="p">.</span><span class="n">my_lookup_name</span>
            <span class="ow">AND</span> <span class="n">ne</span><span class="p">.</span><span class="n">lookup_value</span> <span class="o">=</span> <span class="o">'</span><span class="s1">*</span><span class="o">'</span> 
    <span class="p">)</span> <span class="ow">AND</span> <span class="ow">NOT</span> <span class="kr">EXISTS</span> <span class="p">(</span> <span class="c1">-- not exists 2</span>
        <span class="kr">SELECT</span> <span class="mi">1</span>
        <span class="kr">FROM</span> <span class="n">ne</span>
        <span class="kr">WHERE</span> <span class="n">ne</span><span class="p">.</span><span class="n">lookup_name</span> <span class="o">=</span> <span class="n">a</span><span class="p">.</span><span class="n">my_lookup_name</span>
            <span class="ow">AND</span> <span class="n">ne</span><span class="p">.</span><span class="n">lookup_value</span> <span class="o">&lt;&gt;</span> <span class="o">'</span><span class="s1">*</span><span class="o">'</span> 
            <span class="ow">AND</span> <span class="n">ne</span><span class="p">.</span><span class="n">lookup_value</span> <span class="o">=</span> <span class="n">a</span><span class="p">.</span><span class="n">my_key_value</span>
    <span class="p">)</span>
</code></pre></div></div><table class="img-table-centered"><thead><tr><th style="text-align: center"><em>Figure 2 - Explain Plan of Filter Operation for Antijoin no OR</em><tbody><tr><td style="text-align: center"><img src="/images/hash_aj_or_2.png" alt="" /></table><p>That worked swimmingly. The optimizer hashed all of the rows from <em>ne</em> with a lookup value of ‘*’, also hashed all of the rows from <em>ne</em> with at lookup value that was not ‘*’, and did a <em>HASH JOIN ANTI</em> against each in pipelined series. This was a much more efficient plan that will also scale well as the number of rows increases over time. The actual run time was about a third what it was before the re-write. Honestly I expected better than that, so maybe Oracle is doing some form of optimization on that filter operation under the covers.<p>It is still showing the antijoin of <em>some_other_table</em> as a <em>FILTER</em>. I do not know why this presents as a filter rather than a <em>NESTED LOOP JOIN ANTI</em>. I’ve seen nested loop anti-join be shown by the optimizer rather than filter in other situations and am unsure what the difference is. I went trolling through Jonathan Lewis’s fine book <em>Cost-Based Oracle Fundamentals</em>, but did not find an example of a plan using <em>FILTER</em>. It may be something that Oracle added after 10g which is the release the book covered.<h1 id="conclusion">Conclusion</h1><p>When dealing with <em>OR</em> join conditions (<em>IN</em> lists are <em>OR</em> conditions too), there is only so much the optimizer can do. When you are getting an unacceptable plan for a query with <em>OR</em>s in the join conditions, or especially anti-join conditions, consider how you might be able to rewrite the query with two joins, one for each of the <em>OR</em>s.</div></div><div class="panel-body"><h4>Related Posts</h4><ul><li class="relatedPost"> <a href="https://lee-lindley.github.io/oracle/plsql/2022/11/27/ExcelGen_multirow_headers.html">Creating Multiple Row Headers with ExcelGen PL/SQL Spreadsheet Generator</a> (Categories: <a href="/category/oracle">oracle</a>, <a href="/category/plsql">plsql</a>)<li class="relatedPost"> <a href="https://lee-lindley.github.io/oracle/sql/plsql/2022/11/24/Cursor_from_Collections.html">Create a PL/SQL Cursor from a Nested Table of Nested Tables</a> (Categories: <a href="/category/oracle">oracle</a>, <a href="/category/sql">sql</a>, <a href="/category/plsql">plsql</a>)<li class="relatedPost"> <a href="https://lee-lindley.github.io/oracle/perl/2022/11/13/version_db_objects.html">Versioning Oracle Code from Open Source</a> (Categories: <a href="/category/oracle">oracle</a>, <a href="/category/perl">perl</a>)<li class="relatedPost"> <a href="https://lee-lindley.github.io/oracle/plsql/2022/09/18/spreadsheets_with_plsql.html">Manipulating XLSX Spreadsheets in PL/SQL</a> (Categories: <a href="/category/oracle">oracle</a>, <a href="/category/plsql">plsql</a>)<li class="relatedPost"> <a href="https://lee-lindley.github.io/oracle/perl/2022/04/30/perl_dbd_oracle_clob.html">Using Perl DBD::Oracle to write LOB content</a> (Categories: <a href="/category/oracle">oracle</a>, <a href="/category/perl">perl</a>)<li class="relatedPost"> <a href="https://lee-lindley.github.io/oracle/plsql/sql/vim/2022/04/29/vim-plsql-syntax.html">Syntax Highlighting for PL/SQL in vim</a> (Categories: <a href="/category/oracle">oracle</a>, <a href="/category/plsql">plsql</a>, <a href="/category/sql">sql</a>, <a href="/category/vim">vim</a>)</ul></div><div class="PageNavigation"> <a class="prev" href="/oracle/plsql/2022/09/18/spreadsheets_with_plsql.html">&laquo; Manipulating XLSX Spreadsheets in PL/SQL</a> <a class="next" href="/oracle/perl/2022/11/13/version_db_objects.html">Versioning Oracle Code from Open Source &raquo;</a></div><div class="disqus-comments"><div id="disqus_thread"></div><script type="text/javascript"> /* <![CDATA[ */ var disqus_shortname = "leelindleyscratchpad"; var disqus_identifier = "https://lee-lindley.github.io_Tuning Query with OR Conditions in a NOT EXISTS"; var disqus_title = "Tuning Query with OR Conditions in a NOT EXISTS"; /* * * DON'T EDIT BELOW THIS LINE * * */ (function() { var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true; dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js'; (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq); })(); /* ]]> */ </script></div><footer> &copy; Lee Lindley - <a href="https://github.com/lee-lindley">https://github.com/lee-lindley</a> - Powered by Jekyll.<div class="btn-github" style="float:right;"> <iframe src="https://ghbtns.com/github-btn.html?user=agusmakmun&repo=agusmakmun.github.io&type=star&count=true" frameborder="0" scrolling="0" width="100" height="20px"></iframe> <iframe src="https://ghbtns.com/github-btn.html?user=agusmakmun&repo=agusmakmun.github.io&type=fork&count=true" frameborder="0" scrolling="0" width="100" height="20px"></iframe></div></footer></div></div><script src="//ajax.googleapis.com/ajax/libs/jquery/1.11.0/jquery.min.js"></script> <script src="//code.jquery.com/jquery-migrate-1.2.1.min.js"></script> <script src="/static/js/bootstrap.min.js"></script> <script src="/static/js/super-search.js"></script> <script src="/static/js/thickbox-compressed.js"></script> <script src="/static/js/projects.js"></script>
