<!DOCTYPE html><html><head><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="shortcut icon" href="/static/img/favicon.ico" /><title>Sql Tuning for Multiple Use Cases - Lee Lindley Scratchpad</title><meta name="author" content="Lee Lindley" /><meta name="description" content="Sql Tuning for Multiple Use Cases" /><meta name="keywords" content="Sql Tuning for Multiple Use Cases, Lee Lindley Scratchpad, oracle, sql, plsql" /><link rel="alternate" type="application/rss+xml" title="RSS" href="/feed.xml"><meta content="" property="fb:app_id"><meta content="Lee Lindley Scratchpad" property="og:site_name"><meta content="Sql Tuning for Multiple Use Cases" property="og:title"><meta content="article" property="og:type"><meta content="Posts on Technical Subjects, mostly Oracle and Linux" property="og:description"><meta content="https://lee-lindley.github.io/oracle/sql/plsql/2021/10/17/Use-Case-SQL-Tuning.html" property="og:url"><meta content="2021-10-17T11:30:00-04:00" property="article:published_time"><meta content="https://lee-lindley.github.io/about/" property="article:author"><meta content="oracle" property="article:section"><meta content="oracle" property="article:tag"><meta content="sql" property="article:tag"><meta content="plsql" property="article:tag"><meta content="tuning" property="article:tag"><meta name="twitter:card" content="summary"><meta name="twitter:site" content="@"><meta name="twitter:creator" content="@"><meta name="twitter:title" content="Sql Tuning for Multiple Use Cases"><meta name="twitter:url" content="https://lee-lindley.github.io/oracle/sql/plsql/2021/10/17/Use-Case-SQL-Tuning.html"><meta name="twitter:description" content="Posts on Technical Subjects, mostly Oracle and Linux"><link href="/static/css/font-awesome.min.css" rel="stylesheet" integrity="sha384-T8Gy5hrqNKT+hzMclPo118YTQO6cYprQmhrYwIiQ/3axmI1hQomh7Ud2hPOy8SP1" crossorigin="anonymous"><link rel="stylesheet" href="/static/css/syntax.css"><link href="/static/css/bootstrap.min.css" rel="stylesheet"><link href="https://fonts.googleapis.com/css?family=Roboto+Condensed:400,300italic,300,400italic,700&amp;subset=latin,latin-ext" rel="stylesheet" type="text/css"><link rel="stylesheet" href="/static/css/super-search.css"><link rel="stylesheet" href="/static/css/thickbox.css"><link rel="stylesheet" href="/static/css/projects.css"><link rel="stylesheet" href="/static/css/main.css"><body><div class="container"><div class="col-sm-3"><div class="fixed-condition"><h1 class="author-name"><a href="/">Lee Lindley</a></h1><div class="profile-about"> I'm Just Another Perl Hacker who wound up in a big Oracle Database playground</div><div class="social"><ul><li><a href="https://linkedin.com/in/lee-lindley" target="_blank"><i class="fa fa-linkedin"></i></a><li><a href="https://github.com/lee-lindley" target="_blank"><i class="fa fa-github"></i></a></ul></div><div class="search" id="js-search"> <input type="text" placeholder="(sitemap)~$ type to search" class="search__input form-control" id="js-search__input"><ul class="search__results" id="js-search__results"></ul></div><hr /><ul class="sidebar-nav"> <strong>Navigation</strong><li><a href="/">Home</a><li><a class="about" href="/about/">About Me</a><li><a class="about" href="/projects/">My Projects</a><li><a class="about" href="/feed.xml">XML Feed</a></ul></div></div><div class="col-sm-8 col-offset-1 main-layout"><header class="post-header"><h1 class="post-title">Sql Tuning for Multiple Use Cases</h1></header><span class="time">17 Oct 2021</span> <span class="categories"> &raquo; <a href="/category/oracle">oracle</a>, <a href="/category/sql">sql</a>, <a href="/category/plsql">plsql</a> </span><div class="content"><div class="post"><h1 id="introduction">Introduction</h1><p>The primary goal of tuning an Oracle SQL statement is to obtain the best performance (shortest response time and minimal resourse utilization) for the intended task. The best answer usually achieves both, but occasionally you sacrifice some of one for the other.<p>The Oracle optimizer is good at achieving an optimal execution plan (<em>access path, join order, join mechanism</em>), defined as minimal <em>cost</em>, if it has sufficient statistics about the data. There are reams of books and articles about it. I bashed my head against the rocks of Jonathan Lewis’s book <em>Cost Based Oracle Fundamentals</em> for several years. The subject is so massive and fluid, I do not even pretend to get it all. This article is not about that.<p><strong>The problem to be solved is that we have a single SQL statement with multiple use cases, each of which require a different execution plan.</strong><p>I will present two use cases for this article.<ul><li>A nightly batch that touches a full set of data<li>An incremental, near real-time batch that touches a very small subset of the data</ul><table class="img-table-centered"><thead><tr><th style="text-align: center"><em>Multiple Use Case SQL Statements</em><tbody><tr><td style="text-align: center"><img src="/images/use_case_sql_tuning.gif" alt="use_case_sql_tuning.gif" /></table><p>(In practice I have third and forth use cases of nightly “correction” batches that touch what can be either middling sized sets of the data or really huge, almost full sized subsets.)<p>How can this be addressed?<h1 id="adaptive-plan">Adaptive Plan</h1><p>Modern Oracle databases have <em>dynamic</em> execution plans where the database attempts to re-plan after finding that the statistics used to calculate the original plan do not match reality. That is a good idea, and I am sure it is helpful in situations where the data changes slowly over time. For example at the start of the day one of the source tables may be tiny and a Full Table Scan (FTS) access path is chosen. As the table fills during the day, the <em>adaptive plan</em> logic may determine an Index Access Path is lower cost and switch to it. Adaptive plans may be a great idea and it may solve many issues in many environments,but I have not personally experienced that. Your mileage may vary.<p>The adaptive plan mechanism does not help sufficiently with this use case. Imagine that we start with the nightly batch case where the driver table statistics would tip off the optimizer to use FTS and Hash join plans. Works great for the nightly batch which runs for thirty minutes (or hours). Now we begin the daily mini-batches. We re-gather statistics on our driver table, but Oracle does not bother to re-evaluate our execution plan. Nope, the idiot savant has a perfectly good plan already, and it is going to use it. It does full table scans and hash joins to obtain what we need for our tiny subset of accounts, wasting resources and taking forever on the first <em>near real-time</em> run. Probably on the second one too. By some later run (perhaps hours later) the adaptive plan technology may figure out something isn’t right and substitute a better plan. By now though we are fielding calls from the business that stuff isn’t working right. Booooooooo!<p>Even worse would be the behavior that night. Oracle has a good plan now for the small driver table footprint but when we load it up for the nightly batch, Oracle continues to use an unscalable execution plan with index access that runs all night. Uggghhhh!<h1 id="invalidate-the-plan">Invalidate the Plan</h1><p>We could do something to invalidate the plan forcing Oracle to evaluate the SQL again with the changed statistics.<h2 id="dbms_shared_pool">DBMS_SHARED_POOL</h2><p>Although there is a package named DBMS_SHARED_POOL that provides fine grained control over invalidating individual sql plans, I have yet to meet a DBA willing to grant execute on the package and I do not blame them one bit. You would also have to do so on every instance of a RAC.<h2 id="dbms_stats">DBMS_STATS</h2><p>There is also a parameter you can set during statistics gathering that is supposed to invalidate any SQL plan using the table (no_invalidate =&gt; FALSE), but it comes with caveats and is generally ignored for at least a while. (DMS_STATS.AUTO_INVALIDATE default value is to let Oracle decide and it does not invalidate the plans immediately.)<h2 id="ddl-invalidates-plans">DDL Invalidates Plans</h2><p>At least for Oracle versions 10 through 19, updating a comment on a table counted as DDL that marks all SQL that used the table as needing to be parsed again. (You do have to make the comment different than the existing one though or it is a noop.) Observe:<div class="language-plsql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kr">select</span> <span class="o">*</span> <span class="kr">from</span> <span class="n">app_log_app</span>
<span class="p">;</span>
<span class="kr">SELECT</span> <span class="n">sql_id</span><span class="p">,</span>  <span class="n">parse_calls</span><span class="p">,</span> <span class="n">sql_text</span>
<span class="kr">FROM</span> <span class="n">v$sql</span>
<span class="kr">WHERE</span> <span class="n">sql_text</span> <span class="ow">LIKE</span> <span class="o">'</span><span class="s1">%app_log_app</span><span class="o">'</span>
<span class="ow">AND</span> <span class="n">sql_text</span> <span class="ow">NOT</span> <span class="ow">LIKE</span> <span class="o">'</span><span class="s1">%v$sql%</span><span class="o">'</span>
<span class="p">;</span>
</code></pre></div></div><table><thead><tr><th>SQL_ID<th style="text-align: right">PARSE_CALLS<th>SQL_TEXT<tbody><tr><td>4t32sfzvq63zf<td style="text-align: right">1<td>select * from app_log_app</table><p>Notcie the number of parse calls is <em>one</em>.<div class="language-plsql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">BEGIN</span>
<span class="k">EXECUTE</span> <span class="k">IMMEDIATE</span> <span class="o">q'{</span><span class="sx">COMMENT ON TABLE app_log_app IS 'invalidate plan comment </span><span class="o">}'</span>
    <span class="o">||</span><span class="nf">TO_CHAR</span><span class="p">(</span><span class="nf">SYSDATE</span><span class="p">,</span><span class="o">'</span><span class="s1">MM/DD/YYYY HH24:MI:SS</span><span class="o">'</span><span class="p">)</span>
    <span class="o">||q'{</span><span class="err">'</span><span class="o">}'</span><span class="p">;</span>
<span class="k">END</span><span class="p">;</span>
<span class="o">/</span>
<span class="c1">-- repeat SQL listed above to query the table then v$sql.</span>
</code></pre></div></div><table><thead><tr><th>SQL_ID<th style="text-align: right">PARSE_CALLS<th>SQL_TEXT<tbody><tr><td>4t32sfzvq63zf<td style="text-align: right">2<td>select * from app_log_app</table><p>DDL, even a simple COMMENT, invalidates all plans that reference the object, forcing a re-parse. So we could do this once during the nightly batch after gathering statistics on our driver table, and again on the first run of the mini-batch in the morning. It is a bit fragile though as a solution, and there is a downside that there could be large numbers of SQLs that need to be re-parsed if the table you chose was a common one. The scenario I describe it would be a driver table specific to our process, but one should be aware of the possible impact. Nevertheless, this is a viable answer for the multiple Use Case issue assuming we keep gathering statistics on the driver table when needed.<h1 id="multiple-sql-statements">Multiple Sql Statements</h1><p>So what if we just use two different SQL statements in our code so that we get the right plan for each case?<p>My response, having gone down that road, is “what if they come up with different answers?”. This is particularly egregious if you wind up only testing one path. Worse yet when you go to make changes, you have to make it in two places.<p>It may not be possible to completely avoid this though. If you decide to use a pattern that sometimes uses Update/Delete of records in place, and sometimes does a Create Table AS (CTAS) followed by partition exchange, then of course you will be executing different SQL for the different use cases.<p>Yet whenever possible we should strive to have a single set of code that implements the business logic. This implies we will likely be using Dynamic SQL for the task. Even so, when building the dynamic SQL it would be best if we could avoid having more than one set of code that implements the same <em>logic</em>.<p>“Sure” you say, you get that. But there will come a time when you do it anyway for expediency. I’ve done that, and have the scars to prove it. If you are like me, you will likely have to learn the hard way once or twice before it sticks. Maybe this article will help you avoid as many scars as this slow learner has accumulated.<p>It turns out that using two different SQL statements is the answer I’m proposing as far as the database is concerned, just using a common base.<h1 id="use-case-specific-hints">Use Case Specific Hints</h1><p>Many purists turn up their noses at hints, and lecture you to just make sure your statistics are correct so that the optimizer can determine the best answer.<p>I can happily engage in a religious war dialogue on the subject if you are one who wishes to be pendantic on either side. I can argue both sides fairly well. I agree that if you can solve the issue by controlling the statistics on the tables and indexes, then by all means do so. In particular this means making rational decisions about histograms and partition level statistics. Mastering that can address many issues with both current and future SQL.<p>People who argue against hints often have their opinion informed by too often seeing inappropriate hints used by well meaning developers or business users. I get that too. I’m even guilty of it and I’m sure you are too at least at times over your career.<p>I can also make the case that it is not possible to solve all problems without hints. The case of a piplelined TABLE(f()) function in your query means the optimizer has no clue how many records will come from it. You can give it a <em>cardinality</em> hint, but what if the number of records is variable with the use case?<p>We also just demonstrated that gathering statistics again on a table does not invalidate existing plans.<p>There are other scenarios where you as the data expert simply have more information than the optimizer will determine from statistics, regardless of how carefully you gather or even customize the statistics it uses. That rabbit hole is deep.<p>Let’s embrace the suck and use a minimal set of hints that will guide the optimizer into understanding our use case. The term “minimal” leaves some wiggle room. For the scenario I described we might get by with as little as a single <em>CARDINALITY</em> hint on the driver table plus a degree of parallel hint for the entire query. Example:<div class="language-plsql highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="n">v_sql</span> <span class="o">:=</span> <span class="o">q'!</span><span class="sx">INSERT INTO ...
        SELECT /*+ CARDINALITY(d __DRIVER_TABLE_CARDINALITY__) __PARALLEL__ */
            ...
        FROM my_driver_table d
        INNER JOIN ...
    </span><span class="o">!'</span><span class="p">;</span>
    <span class="o">..</span><span class="p">.</span>
    <span class="k">EXECUTE</span> <span class="k">IMMEDIATE</span> <span class="nf">REPLACE</span><span class="p">(</span>
        <span class="nf">REPLACE</span><span class="p">(</span><span class="n">v_sql</span><span class="p">,</span> <span class="o">'</span><span class="s1">__DRIVER_TABLE_CARDINALITY__</span><span class="o">'</span>
            <span class="p">,</span><span class="k">CASE</span> <span class="k">WHEN</span> <span class="n">p_is_nightly_batch</span> <span class="kr">THEN</span> <span class="o">'</span><span class="s1">1000000</span><span class="o">'</span> <span class="kr">ELSE</span> <span class="o">'</span><span class="s1">10</span><span class="o">'</span> <span class="k">END</span>
            <span class="p">),</span> <span class="o">'</span><span class="s1">__PARALLEL__</span><span class="o">'</span><span class="p">,</span> 
                <span class="p">,</span><span class="k">CASE</span> <span class="k">WHEN</span> <span class="n">p_is_nightly_batch</span> <span class="kr">THEN</span> <span class="o">'</span><span class="s1">PARALLEL(16)</span><span class="o">'</span> <span class="kr">ELSE</span> <span class="o">'</span><span class="s1">NO_PARALLEL</span><span class="o">'</span> <span class="k">END</span>
    <span class="p">);</span>
</code></pre></div></div><p>When we call our procedure the parameter p_is_nightly_batch will be TRUE or FALSE. Now the numbers 10 and a million are not exactly what we have in our driver table, and in fact we could get a mini-batch where the number of records is enough that we would be better off with a different plan than that we get from telling the optimizer to assume 10 records. That is something you might have to experiment with.<p>Note that this winds up being two different SQL statements in v$sql, each with a different plan.<p>Putting the parallel degree into the hint is somewhat controversial. One can say it should be determined from the DOP on the table. There are other considerations depending on system load. That is a topic for another day.<p>In practice I would likely put those values, 10 and 100000 plus the DOP, into a parameter table that I could adjust at run time. (See <em>app_parameter</em> in <a href="https://github.com/lee-lindley/plsql_utilities">plsql_utilities</a>.) That way if something happened either over time or during a particular event, I could adjust the values fed to the optimizer on the fly, and since the text of the SQL is different from that already parsed, it of course parses again with the new hint value.<p>This may not be enough though. There are cases where the optimizer simply refuses to come up with a correct plan without hints, and you must bludgeon it into submission. I offer <a href="https://jonathanlewis.wordpress.com/2020/12/08/hash-joins-2/">this article on hash joins</a> as an example of how you might want to compel the optimizer to do things a particular way (though I am almost certain Mr. Lewis would never say the words “bludgeon optimizer into submission”).<p>You may likely find yourself needing to use more than a single cardinality hint plus degree of parallelism. Example:<div class="language-plsql highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="n">v_sql</span> <span class="o">:=</span> <span class="o">q'!</span><span class="sx">INSERT INTO ...
        SELECT 
            /*+ 
                __USE_CASE_HINT__
            */
            ...
        FROM my_driver_table d
        INNER JOIN big_table1 t1
            ON ...
        INNER JOIN midsize_table2 t2
            ON ...
        INNER JOIN big_table t3
            ON ...
    </span><span class="o">!'</span><span class="p">;</span>
    <span class="o">..</span><span class="p">.</span>
    <span class="k">EXECUTE</span> <span class="k">IMMEDIATE</span> <span class="nf">REPLACE</span><span class="p">(</span><span class="n">v_sql</span><span class="p">,</span> <span class="o">'</span><span class="s1">__USE_CASE_HINT__</span><span class="o">'</span>
        <span class="p">,</span><span class="k">CASE</span> <span class="k">WHEN</span> <span class="n">p_is_nightly_batch</span> 
            <span class="kr">THEN</span> <span class="o">q'+</span><span class="sx">
                leading(d t1 t2 t3)
                full(d)
                use_hash(t1) full(t1) swap_join_inputs(t1)
                use_hash(t2) full(t2) no_swap_join_inputs(t2)
                use_hash(t3) full(t3) swap_join_inputs(t3)
                </span><span class="o">+'</span>
            <span class="kr">ELSE</span> <span class="o">q'+</span><span class="sx">
                leading(d t1 t2 t3)
                full(d)
                use_nl(t1) index(t1)
                use_nl(t2) index(t2)
                use_nl(t3) index_ss(t3)
                </span><span class="o">+'</span>
            <span class="k">END</span>
    <span class="p">);</span>
</code></pre></div></div><p>As you can imagine it can get fairly complex especially if you have a very large query perhaps broken down using WITH query subfactoring (as I heartily recommend). It would be good to establish a naming convention for the hint parameters. You may also want to add an option to the procedure call that prints the SQL with DBMS_OUTPUT rather than executing it. It will help with debugging and establishing the best plan.<h1 id="conclusion">Conclusion</h1><p>When you have one business problem with multiple SQL optimization use cases, make every attempt to keep the business logic in a single set of code. Decorate the dynamic sql with replaceable hints that are appropriate for the use case. Use the minimal set of hints that achieve the objective, but also give yourself some room to adapt when the datbase changes out from under you. Parameterizing the hint values so that they may be changed at run time is a good option that does NOT mean you are changing the code at run time. The actual business logic is that which was tested and promoted to production. Only the optimization is changing and that in response to a business need. This is a solution that comports with best practices while providing some flexibility.</div></div><div class="panel-body"><h4>Related Posts</h4><ul><li class="relatedPost"> <a href="https://lee-lindley.github.io/oracle/perl/2022/11/13/version_db_objects.html">Versioning Oracle Code from Open Source</a> (Categories: <a href="/category/oracle">oracle</a>, <a href="/category/perl">perl</a>)<li class="relatedPost"> <a href="https://lee-lindley.github.io/oracle/sql/2022/10/09/antijoins_with_or.html">Tuning Query with OR Conditions in a NOT EXISTS</a> (Categories: <a href="/category/oracle">oracle</a>, <a href="/category/sql">sql</a>)<li class="relatedPost"> <a href="https://lee-lindley.github.io/oracle/plsql/2022/09/18/spreadsheets_with_plsql.html">Manipulating XLSX Spreadsheets in PL/SQL</a> (Categories: <a href="/category/oracle">oracle</a>, <a href="/category/plsql">plsql</a>)<li class="relatedPost"> <a href="https://lee-lindley.github.io/oracle/perl/2022/04/30/perl_dbd_oracle_clob.html">Using Perl DBD::Oracle to write LOB content</a> (Categories: <a href="/category/oracle">oracle</a>, <a href="/category/perl">perl</a>)<li class="relatedPost"> <a href="https://lee-lindley.github.io/oracle/plsql/sql/vim/2022/04/29/vim-plsql-syntax.html">Syntax Highlighting for PL/SQL in vim</a> (Categories: <a href="/category/oracle">oracle</a>, <a href="/category/plsql">plsql</a>, <a href="/category/sql">sql</a>, <a href="/category/vim">vim</a>)<li class="relatedPost"> <a href="https://lee-lindley.github.io/oracle/perl/linux/2022/04/28/Perl-DBD-Oracle-RHL.html">Installing Perl DBD::Oracle on RHL</a> (Categories: <a href="/category/oracle">oracle</a>, <a href="/category/perl">perl</a>, <a href="/category/linux">linux</a>)</ul></div><div class="PageNavigation"> <a class="prev" href="/oracle/sql/plsql/2021/09/25/Inline-PLSQL-Methods.html">&laquo; Why do I need Inline PL/SQL Methods?</a> <a class="next" href="/oracle/sql/plsql/2021/12/18/sqlplus-blob.html">Extracting BLOB from Oracle with Sqlplus &raquo;</a></div><div class="disqus-comments"><div id="disqus_thread"></div><script type="text/javascript"> /* <![CDATA[ */ var disqus_shortname = "leelindleyscratchpad"; var disqus_identifier = "https://lee-lindley.github.io_Sql Tuning for Multiple Use Cases"; var disqus_title = "Sql Tuning for Multiple Use Cases"; /* * * DON'T EDIT BELOW THIS LINE * * */ (function() { var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true; dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js'; (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq); })(); /* ]]> */ </script></div><footer> &copy; Lee Lindley - <a href="https://github.com/lee-lindley">https://github.com/lee-lindley</a> - Powered by Jekyll.<div class="btn-github" style="float:right;"> <iframe src="https://ghbtns.com/github-btn.html?user=agusmakmun&repo=agusmakmun.github.io&type=star&count=true" frameborder="0" scrolling="0" width="100" height="20px"></iframe> <iframe src="https://ghbtns.com/github-btn.html?user=agusmakmun&repo=agusmakmun.github.io&type=fork&count=true" frameborder="0" scrolling="0" width="100" height="20px"></iframe></div></footer></div></div><script src="//ajax.googleapis.com/ajax/libs/jquery/1.11.0/jquery.min.js"></script> <script src="//code.jquery.com/jquery-migrate-1.2.1.min.js"></script> <script src="/static/js/bootstrap.min.js"></script> <script src="/static/js/super-search.js"></script> <script src="/static/js/thickbox-compressed.js"></script> <script src="/static/js/projects.js"></script>
