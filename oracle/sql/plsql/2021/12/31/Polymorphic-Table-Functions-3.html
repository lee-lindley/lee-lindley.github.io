<!DOCTYPE html><html><head><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="shortcut icon" href="/static/img/favicon.ico" /><title>Polymorphic Table Function (PTF) for CSV (take 3) - Lee Lindley Scratchpad</title><meta name="author" content="Lee Lindley" /><meta name="description" content="Polymorphic Table Function (PTF) for CSV (take 3)" /><meta name="keywords" content="Polymorphic Table Function (PTF) for CSV (take 3), Lee Lindley Scratchpad, oracle, sql, plsql" /><link rel="alternate" type="application/rss+xml" title="RSS" href="/feed.xml"><meta content="" property="fb:app_id"><meta content="Lee Lindley Scratchpad" property="og:site_name"><meta content="Polymorphic Table Function (PTF) for CSV (take 3)" property="og:title"><meta content="article" property="og:type"><meta content="Posts on Technical Subjects, mostly Oracle and Linux" property="og:description"><meta content="https://lee-lindley.github.io/oracle/sql/plsql/2021/12/31/Polymorphic-Table-Functions-3.html" property="og:url"><meta content="2021-12-31T10:30:00-05:00" property="article:published_time"><meta content="https://lee-lindley.github.io/about/" property="article:author"><meta content="oracle" property="article:section"><meta content="oracle" property="article:tag"><meta content="sql" property="article:tag"><meta content="plsql" property="article:tag"><meta name="twitter:card" content="summary"><meta name="twitter:site" content="@"><meta name="twitter:creator" content="@"><meta name="twitter:title" content="Polymorphic Table Function (PTF) for CSV (take 3)"><meta name="twitter:url" content="https://lee-lindley.github.io/oracle/sql/plsql/2021/12/31/Polymorphic-Table-Functions-3.html"><meta name="twitter:description" content="Posts on Technical Subjects, mostly Oracle and Linux"><link href="/static/css/font-awesome.min.css" rel="stylesheet" integrity="sha384-T8Gy5hrqNKT+hzMclPo118YTQO6cYprQmhrYwIiQ/3axmI1hQomh7Ud2hPOy8SP1" crossorigin="anonymous"><link rel="stylesheet" href="/static/css/syntax.css"><link href="/static/css/bootstrap.min.css" rel="stylesheet"><link href="https://fonts.googleapis.com/css?family=Roboto+Condensed:400,300italic,300,400italic,700&amp;subset=latin,latin-ext" rel="stylesheet" type="text/css"><link rel="stylesheet" href="/static/css/super-search.css"><link rel="stylesheet" href="/static/css/thickbox.css"><link rel="stylesheet" href="/static/css/projects.css"><link rel="stylesheet" href="/static/css/main.css"><body><div class="container"><div class="col-sm-3"><div class="fixed-condition"><h1 class="author-name"><a href="/">Lee Lindley</a></h1><div class="profile-about"> I'm Just Another Perl Hacker who wound up in a big Oracle Database playground</div><div class="social"><ul><li><a href="https://linkedin.com/in/lee-lindley" target="_blank"><i class="fa fa-linkedin"></i></a><li><a href="https://github.com/lee-lindley" target="_blank"><i class="fa fa-github"></i></a></ul></div><div class="search" id="js-search"> <input type="text" placeholder="(sitemap)~$ type to search" class="search__input form-control" id="js-search__input"><ul class="search__results" id="js-search__results"></ul></div><hr /><ul class="sidebar-nav"> <strong>Navigation</strong><li><a href="/">Home</a><li><a class="about" href="/about/">About Me</a><li><a class="about" href="/projects/">My Projects</a><li><a class="about" href="/feed.xml">XML Feed</a></ul></div></div><div class="col-sm-8 col-offset-1 main-layout"><header class="post-header"><h1 class="post-title">Polymorphic Table Function (PTF) for CSV (take 3)</h1></header><span class="time">31 Dec 2021</span> <span class="categories"> &raquo; <a href="/category/oracle">oracle</a>, <a href="/category/sql">sql</a>, <a href="/category/plsql">plsql</a> </span><div class="content"><div class="post"><h2 id="why-polymorphic-table-functions-ptf">Why Polymorphic Table Functions (PTF)?</h2><p>They let you code a resultset transformation for the SQL engine without knowing at compile time either or both of<ol><li>The input cursor/resultset definition.<li>The output cursor/resultset definition.</ol><p>Ordinary Pipelined Table Functions already let you consume any type of input, but you must build your own code to figure out what is in it, generally by using <em>DBMS_SQL</em>. If you want to see how that is done, I have a User Defined Type Object <a href="https://github.com/lee-lindley/plsql_utilities/tree/main/app_dbms_sql">app_dbms_sql_udt</a> you can check out. Ordinary Pipelined Table Functions require that you define the output type at compile time.<p>Even if you can define your output resultset at compile time, the PTF functionality takes care of many of the details you must otherwise encode manually with <em>DBMS_SQL</em>. As I’ll demonstrate later, the amount of code needed to produce a CSV file generator is substantially less using a PTF than <em>DBMS_SQL</em>.<h2 id="polymorphic-table-function-tutorials-and-examples">Polymorphic Table Function Tutorials and Examples</h2><p>Oracle’s introduction to Polymorphic Table Functions is in the <em>Database PL/SQL Language Reference</em> <a href="https://docs.oracle.com/en/database/oracle/oracle-database/19/lnpls/plsql-optimization-and-tuning.html#GUID-981102A8-5204-4931-B10A-93486304B184">12.6 Overview of Polymorphic Table Functions</a>. <em>PL/SQL Packages and Types Reference</em> has documentation for the <a href="https://docs.oracle.com/en/database/oracle/oracle-database/19/arpls/DBMS_TF.html">DBMS_TF</a> package that provides the server side implementation. When I want to really understand the types and constants I found it easier to look directly at the <em>DBMS_TF</em> package specification in the database using the Toad or SqlDeveloper schema browser. The types and constants are scattered through the documentation which makes them a little harder to put together than looking straight at the package spec.<p>The best beginner introduction to PTFs I found was by Tim Hall <a href="https://oracle-base.com/articles/18c/polymorphic-table-functions-18c">Polymorphic Table Functions in Oracle Database 18c</a>. He has simple examples to lead you in gently.<p>There are a suite of example PTF implementations in the <a href="https://livesql.oracle.com/">Oracle LiveSql collection</a>. Enter the search term “polymorphic table function”. This <a href="https://blogs.oracle.com/oraclemagazine/post/how-to-dynamically-change-the-columns-in-a-sql-query">article from Oracle Magazine by Chris Saxon</a> goes along with one of them and I found it helpful.<h2 id="replication_factor">Replication_Factor</h2><p>The general design pattern for a PTF is that it transforms rows from one result set into another. By default there is a one to one relationship on the number of rows OUT to the number of rows IN. You can choose to include columns from the input row in the output row by setting the column <em>pass_through</em> flag to TRUE. You can add new columns to the output resultset. Whether you have any passthrough columns or not, there is still a relationship between the number of input rows and the number of output rows the function will produce from your <em>New_Columns</em> tables. In other words you might set all of the input columns to <em>pass_through</em>=FALSE, but the PTF will only produce the number of rows from your <em>New_Columns</em> tables that match the number of rows of your input resultset.<p>There is a capability to specify how many output rows there are for any given input row using <em>DBMS_TF.row_replication</em> procedure (or a scalar parameter). The procedure version requires an argument that is an index-by table you populate with a numeric value for every input row in that <em>fetch_rows</em> call. Note how carefully I stated that. You can control the number of output rows counted for each and every input row by populating an array with a numeric value for every input row. You can do that for any of the <em>fetch_rows</em> calls but do not have to do so for all of them. If you do not call <em>row_replication</em> procedure during a particular <em>fetch_rows</em>, then you get one to one row output.<p>You can have 0, 1 or more output rows for any specific input row. If a column from an input row is marked with <em>pass_through</em>=TRUE, you will get that value in your output if replication factor is 1. You will get it on 2 rows if the replication factor is 2, etc… If the replication factor is 0 for that input row, you will not see that value in the output. In the diagram below, the input value from row 2 will not appear in the output resultset. The number of output rows will be the sum of the <em>replication factor</em> values.<table class="img-table-centered"><thead><tr><th style="text-align: center"><em>PTF Replication Factor</em><tbody><tr><td style="text-align: center"><img src="/images/PTF_Replication_Factor.gif" alt="PTF Replication Factor" /></table><p>In the work I’ve done with CSV data I have been setting all input columns to <em>pass_through</em>=FALSE and using the <em>replication_factor</em> strictly as a way to tell Oracle how many output rows are in my output column arrays. When you have <em>pass_through</em>=TRUE you have to understand what Oracle does behind the scenes and how the two arrays match up.<h2 id="walk-through-a-ptf-example">Walk Through a PTF Example</h2><p>We will walk through a Polymorphic Table Function and an associated package for creating a CSV file from an Oracle query. This requires Oracle 18c or better.<p>I have a prior effort for CSV file creation at <a href="https://github.com/lee-lindley/app_csv">app_csv_udt</a> that should run under Oracle 10g or later. It is an Oracle Object Type, an approach I happen to like, but my coworkers not so much.<p>That earlier code is more complicated than this effort using a PTF. Oracle has taken care of most of the gnarly cursor management and bulk array processing leaving us with less to do in the PTF guts of our package. That doesn’t mean it is simple. I found the PTF functionality a struggle to grasp. The documentation is light and the examples I see published didn’t help me understand how it worked on the inside and what our design choices were as easily as I pick up many new things. When I look back at the examples different things stand out now than when I first went through them, so perhaps I just had a blind spot. I hope this article may help a few people learn about PTFs more easily.<p>The complete implementation can be found in the <a href="https://github.com/lee-lindley/plsql_utilities#app_csv_pkg">PLSQL_utilities library</a> I maintain on github.<h2 id="the-ptf-components">The PTF Components</h2><ol><li>The PTF function specification may be standalone, but it makes sense to me to include it in the package. Since it is part of the package which has a descriptive name, I named the function simply <em>ptf</em>. Note that there is no function body for the PTF function and no entry for it in the package body. It exists only in the package specification.<li>The <em>describe</em> function is a required element to support the PTF. It is usually not that complex (at least as far as I have seen so far).<li>The <em>fetch_rows</em> procedure is where we do most of the work to transform our input resultset to an output resultset.</ol><p>Here are the PTF components of the package specification for our Example. There are a few more utility procedures and functions we will add later. The package name is <em>app_csv_pkg</em>.<div class="language-plsql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kr">CREATE</span> <span class="kr">OR</span> <span class="kr">REPLACE</span> <span class="kr">PACKAGE</span> <span class="n">app_csv_pkg</span> 
<span class="k">AUTHID</span> <span class="k">CURRENT_USER</span>
<span class="kr">AS</span>
    <span class="c1">--</span>
    <span class="c1">-- All non numeric fields will be surrounded with double quotes. Any double quotes in the</span>
    <span class="c1">-- data will be backwacked to protect them. Newlines in the data are passed through as is</span>
    <span class="c1">-- which might cause issues for some CSV parsers.</span>
    <span class="k">FUNCTION</span> <span class="n">ptf</span><span class="p">(</span>
        <span class="n">p_tab</span>                   <span class="kr">TABLE</span>
        <span class="p">,</span><span class="n">p_header_row</span>           <span class="kt">VARCHAR2</span> <span class="o">:=</span> <span class="o">'</span><span class="s1">Y</span><span class="o">'</span>
        <span class="p">,</span><span class="n">p_separator</span>            <span class="kt">VARCHAR2</span> <span class="o">:=</span> <span class="o">'</span><span class="s1">,</span><span class="o">'</span>
        <span class="c1">-- you can set these to NULL if you want the default TO_CHAR conversions</span>
        <span class="p">,</span><span class="n">p_date_format</span>          <span class="kt">VARCHAR2</span> <span class="o">:=</span> <span class="kr">NULL</span>
        <span class="p">,</span><span class="n">p_interval_format</span>      <span class="kt">VARCHAR2</span> <span class="o">:=</span> <span class="kr">NULL</span>
    <span class="p">)</span> <span class="k">RETURN</span> <span class="kr">TABLE</span> <span class="kr">PIPELINED</span> 
        <span class="kr">TABLE</span> <span class="c1">-- so can ORDER the input</span>
        <span class="c1">--ROW </span>
        <span class="kr">POLYMORPHIC</span> <span class="k">USING</span> <span class="n">app_csv_pkg</span>
    <span class="p">;</span>

    <span class="c1">-- the describe and fetch methods are used exclusively by the PTF mechanism. You cannot</span>
    <span class="c1">-- call them directly.</span>
    <span class="k">FUNCTION</span> <span class="n">describe</span><span class="p">(</span>
        <span class="n">p_tab</span> <span class="ow">IN</span> <span class="kr">OUT</span>            <span class="n">DBMS_TF</span><span class="p">.</span><span class="n">TABLE_T</span>
        <span class="p">,</span><span class="n">p_header_row</span>           <span class="kt">VARCHAR2</span> <span class="o">:=</span> <span class="o">'</span><span class="s1">Y</span><span class="o">'</span>
        <span class="p">,</span><span class="n">p_separator</span>            <span class="kt">VARCHAR2</span> <span class="o">:=</span> <span class="o">'</span><span class="s1">,</span><span class="o">'</span>
        <span class="c1">-- you can set these to NULL if you want the default TO_CHAR conversions</span>
        <span class="p">,</span><span class="n">p_date_format</span>          <span class="kt">VARCHAR2</span> <span class="o">:=</span> <span class="kr">NULL</span>
        <span class="p">,</span><span class="n">p_interval_format</span>      <span class="kt">VARCHAR2</span> <span class="o">:=</span> <span class="kr">NULL</span>
    <span class="p">)</span> <span class="k">RETURN</span> <span class="n">DBMS_TF</span><span class="p">.</span><span class="n">DESCRIBE_T</span>
    <span class="p">;</span>
    <span class="k">PROCEDURE</span> <span class="n">fetch_rows</span><span class="p">(</span>
         <span class="n">p_header_row</span>           <span class="kt">VARCHAR2</span> <span class="o">:=</span> <span class="o">'</span><span class="s1">Y</span><span class="o">'</span>
        <span class="p">,</span><span class="n">p_separator</span>            <span class="kt">VARCHAR2</span> <span class="o">:=</span> <span class="o">'</span><span class="s1">,</span><span class="o">'</span>
        <span class="c1">-- you can set these to NULL if you want the default TO_CHAR conversions</span>
        <span class="p">,</span><span class="n">p_date_format</span>          <span class="kt">VARCHAR2</span> <span class="o">:=</span> <span class="kr">NULL</span>
        <span class="p">,</span><span class="n">p_interval_format</span>      <span class="kt">VARCHAR2</span> <span class="o">:=</span> <span class="kr">NULL</span>
    <span class="p">)</span>
    <span class="p">;</span>
<span class="o">..</span><span class="p">.</span>
</code></pre></div></div><p>Notice how the first argument to the function named <em>ptf</em> is of type <em>TABLE</em>. That is special in PTF land. It must be either a schema level table or view name, or else a Common Table Expression (CTE) (aka WITH clause). You cannot pass in a CURSOR or subselect. I vaguely understand the reasons for that, but not well enough to try to explain. The first argument with the same name is given to the <em>describe</em> function, but it has a different type.<p>If you have COLUMNS Pseudo-Operator arguments, they are to be the same between the PTF and <em>describe</em> functions (except for type – see below).<p>Neither the TABLE nor COLUMNS type arguments are passed to the <em>fetch_rows</em> procedure.<p>This gem from the <em>DBMS_TF</em> documentation says what I just said:<blockquote><p>The arguments of the PTF function and DESCRIBE function must match, but with the type of any TABLE argument replaced with the DBMS_TF.TABLE_T descriptor type, and the type of any COLUMNS argument replaced with DBMS_TF.COLUMN_T descriptor.</blockquote><p>All of the other arguments to all three methods are application specific and must be identical between the three methods. Even though you may not need the arguments in the <em>describe</em> function, the argument footprint much match what the SQL engine is going to provide in the call based on what it sees in the PTF definition.<p>It is interesting that our <em>describe</em> and <em>fetch_rows</em> methods are stateless. The SQL engine code that calls our methods maintains the state. When we call <em>get/put</em> methods that state is respected. There is an identifier called the XID that indexes that runtime state. It looks similar to the “Cursor id” value in <em>DBMS_SQL</em>.<h2 id="the-describe-function">The <em>describe</em> Function</h2><p>From the package body:<div class="language-plsql highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="k">FUNCTION</span> <span class="n">describe</span><span class="p">(</span>
        <span class="n">p_tab</span> <span class="ow">IN</span> <span class="kr">OUT</span>            <span class="n">DBMS_TF</span><span class="p">.</span><span class="n">TABLE_T</span>
        <span class="p">,</span><span class="n">p_header_row</span>           <span class="kt">VARCHAR2</span> <span class="o">:=</span> <span class="o">'</span><span class="s1">Y</span><span class="o">'</span>
        <span class="p">,</span><span class="n">p_separator</span>            <span class="kt">VARCHAR2</span> <span class="o">:=</span> <span class="o">'</span><span class="s1">,</span><span class="o">'</span>
        <span class="c1">-- you can set these to NULL if you want the default TO_CHAR conversions</span>
        <span class="p">,</span><span class="n">p_date_format</span>          <span class="kt">VARCHAR2</span> <span class="o">:=</span> <span class="kr">NULL</span>
        <span class="p">,</span><span class="n">p_interval_format</span>      <span class="kt">VARCHAR2</span> <span class="o">:=</span> <span class="kr">NULL</span>
    <span class="p">)</span> <span class="k">RETURN</span> <span class="n">DBMS_TF</span><span class="p">.</span><span class="n">DESCRIBE_T</span>
    <span class="kr">AS</span>
        <span class="n">v_new_cols</span>  <span class="n">DBMS_TF</span><span class="p">.</span><span class="n">columns_new_t</span><span class="p">;</span>
    <span class="k">BEGIN</span>
        <span class="c1">-- stop all input columns from being in the output </span>
        <span class="kr">FOR</span> <span class="n">i</span> <span class="ow">IN</span> <span class="mi">1</span><span class="o">..</span><span class="n">p_tab</span><span class="p">.</span><span class="n">column</span><span class="p">.</span><span class="nf">COUNT</span><span class="p">()</span>
        <span class="kr">LOOP</span>
            <span class="n">p_tab</span><span class="p">.</span><span class="n">column</span><span class="p">(</span><span class="n">i</span><span class="p">).</span><span class="n">pass_through</span> <span class="o">:=</span> <span class="k">FALSE</span><span class="p">;</span>
            <span class="n">p_tab</span><span class="p">.</span><span class="n">column</span><span class="p">(</span><span class="n">i</span><span class="p">).</span><span class="n">for_read</span> <span class="o">:=</span> <span class="k">TRUE</span><span class="p">;</span>
        <span class="k">END</span> <span class="kr">LOOP</span><span class="p">;</span>
        <span class="c1">-- create a single new output column for the CSV row string</span>
        <span class="n">v_new_cols</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="o">:=</span> <span class="n">DBMS_TF</span><span class="p">.</span><span class="n">column_metadata_t</span><span class="p">(</span>
                                    <span class="k">name</span>    <span class="o">=&gt;</span> <span class="o">'</span><span class="s1">CSV_ROW</span><span class="o">'</span>
                                    <span class="p">,</span><span class="k">type</span>   <span class="o">=&gt;</span> <span class="n">DBMS_TF</span><span class="p">.</span><span class="n">type_varchar2</span>
                                <span class="p">);</span>

        <span class="c1">-- we will use row replication to put a header out on the first row if desired</span>
        <span class="k">RETURN</span> <span class="n">DBMS_TF</span><span class="p">.</span><span class="n">describe_t</span><span class="p">(</span><span class="n">new_columns</span> <span class="o">=&gt;</span> <span class="n">v_new_cols</span><span class="p">,</span> <span class="n">row_replication</span> <span class="o">=&gt;</span> <span class="n">p_header_row</span> <span class="ow">IN</span> <span class="p">(</span><span class="o">'</span><span class="s1">Y</span><span class="o">'</span><span class="p">,</span><span class="o">'</span><span class="s1">y</span><span class="o">'</span><span class="p">));</span>
    <span class="k">END</span> <span class="n">describe</span>
    <span class="p">;</span>
</code></pre></div></div><p>We need to examine all of the input column values but we do not want them to be passed through to our output rows. To that end we loop through the input column list setting <em>pass_through</em> to FALSE and <em>for_read</em> to TRUE.<p>We will be defining a single “new” column for our output rowset. To do that we need a table of column types which we get with the type <em>DBMS_TF.columns_new_t</em> for our variable <em>v_new_cols</em>. We then populate the first and only element of that table with a <em>column_metadata_t</em> record with values for the column <em>name</em> and column <em>type</em>. Note that the type is a numeric we get from a constant, not the descriptive name like ‘VARCHAR2’. Digesting this bit of convoluted crafting is where it is handy to be staring at the package specification for <em>DBMS_TF</em>. It is easier than hunting through the type definitions in the documentation.<p>The thing we return from the <em>describe</em> function is a <em>describe_t</em> record. We populate <em>new_columns</em> with the structure we populated for our new output column named ‘CSV_ROW’. We also provide a boolean value for <em>row_replication</em>. We set that to TRUE if we need to produce a header row. If we do not need to produce a header row, we will have one to one correspondence of output rows from input rows so no replication is required.<h2 id="the-fetch_rows-procedure">The <em>fetch_rows</em> Procedure</h2><p><em>fetch_rows</em> is where most of the work is done. There is a lot to unpack here<div class="language-plsql highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="k">PROCEDURE</span> <span class="n">fetch_rows</span><span class="p">(</span>
         <span class="n">p_header_row</span>           <span class="kt">VARCHAR2</span> <span class="o">:=</span> <span class="o">'</span><span class="s1">Y</span><span class="o">'</span>
        <span class="p">,</span><span class="n">p_separator</span>            <span class="kt">VARCHAR2</span> <span class="o">:=</span> <span class="o">'</span><span class="s1">,</span><span class="o">'</span>
        <span class="c1">-- you can leave these NULL if you want the default TO_CHAR conversions for your session</span>
        <span class="p">,</span><span class="n">p_date_format</span>          <span class="kt">VARCHAR2</span> <span class="o">:=</span> <span class="kr">NULL</span>
        <span class="p">,</span><span class="n">p_interval_format</span>      <span class="kt">VARCHAR2</span> <span class="o">:=</span> <span class="kr">NULL</span>
    <span class="p">)</span> <span class="kr">AS</span>
        <span class="n">v_env</span>               <span class="n">DBMS_TF</span><span class="p">.</span><span class="n">env_t</span> <span class="o">:=</span> <span class="n">DBMS_TF</span><span class="p">.</span><span class="n">get_env</span><span class="p">();</span>
        <span class="n">v_rowset</span>            <span class="n">DBMS_TF</span><span class="p">.</span><span class="n">row_set_t</span><span class="p">;</span>  <span class="c1">-- the input rowset of CSV rows</span>
        <span class="n">v_row_cnt</span>           <span class="kt">BINARY_INTEGER</span><span class="p">;</span>
        <span class="n">v_col_cnt</span>           <span class="kt">BINARY_INTEGER</span><span class="p">;</span>
        <span class="c1">--</span>
        <span class="n">v_val_col</span>           <span class="n">DBMS_TF</span><span class="p">.</span><span class="n">tab_varchar2_t</span><span class="p">;</span>
        <span class="n">v_repfac</span>            <span class="n">DBMS_TF</span><span class="p">.</span><span class="n">tab_naturaln_t</span><span class="p">;</span>
        <span class="n">v_fetch_pass</span>        <span class="kt">BINARY_INTEGER</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="n">v_out_row_i</span>         <span class="kt">BINARY_INTEGER</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span>
</code></pre></div></div><p><em>v_rowset</em> will contain our input data for this fetch. <em>v_val_col</em> is a collection where we will place our output data for this fetch. <em>v_repfac</em> is where we MAY put a numeric value for each input row that will be 2 on the first row and 1 on all the rest. The reason we need that is to produce a header row. We need to output one more row than we have input rows, but we only need to do that on the first fetch. After that it won’t be necessary to populate or use <em>v_repfac</em>.<p><em>v_fetch_pass</em> is used to determine whether or not we are on the first fetch and <em>v_out_row_i</em> is to keep track of the number of output rows on this fetch iteration.<div class="language-plsql highlighter-rouge"><div class="highlight"><pre class="highlight"><code>        <span class="c1">-- If the user does not want to change the NLS formats for the session</span>
        <span class="c1">-- but has custom coversions for this query, then we will apply them using TO_CHAR</span>
        <span class="k">TYPE</span> <span class="n">t_conv_fmt</span> <span class="kr">IS</span> <span class="kr">RECORD</span><span class="p">(</span>
            <span class="n">t</span>   <span class="kt">BINARY_INTEGER</span>  <span class="c1">-- type</span>
            <span class="p">,</span><span class="n">f</span>  <span class="kt">VARCHAR2</span><span class="p">(</span><span class="mi">1024</span><span class="p">)</span>  <span class="c1">-- to_char fmt string</span>
        <span class="p">);</span>
        <span class="k">TYPE</span> <span class="n">t_tab_conv_fmt</span> <span class="kr">IS</span> <span class="kr">TABLE</span> <span class="kr">OF</span> <span class="n">t_conv_fmt</span> <span class="kr">INDEX</span> <span class="kr">BY</span> <span class="kt">BINARY_INTEGER</span><span class="p">;</span>
        <span class="n">v_conv_fmts</span>         <span class="n">t_tab_conv_fmt</span><span class="p">;</span>
        <span class="c1">--</span>
        <span class="k">FUNCTION</span> <span class="n">apply_cust_conv</span><span class="p">(</span>
            <span class="n">p_col_index</span>     <span class="kt">BINARY_INTEGER</span>
            <span class="p">,</span><span class="n">p_row_index</span>    <span class="kt">BINARY_INTEGER</span>
        <span class="p">)</span> <span class="k">RETURN</span> <span class="kt">VARCHAR2</span>
        <span class="kr">IS</span>
            <span class="n">v_s</span> <span class="kt">VARCHAR2</span><span class="p">(</span><span class="mi">4000</span><span class="p">);</span>
        <span class="k">BEGIN</span>
            <span class="n">v_s</span> <span class="o">:=</span> <span class="k">CASE</span> <span class="k">WHEN</span> <span class="n">v_conv_fmts</span><span class="p">.</span><span class="n">EXISTS</span><span class="p">(</span><span class="n">p_col_index</span><span class="p">)</span> <span class="kr">THEN</span>
                      <span class="o">'</span><span class="s1">"</span><span class="o">'</span>
                        <span class="o">||</span><span class="nf">REPLACE</span><span class="p">(</span>
                            <span class="k">CASE</span> <span class="n">v_conv_fmts</span><span class="p">(</span><span class="n">p_col_index</span><span class="p">).</span><span class="n">t</span>
                                <span class="k">WHEN</span> <span class="n">DBMS_TF</span><span class="p">.</span><span class="n">type_date</span> <span class="kr">THEN</span> 
                                    <span class="nf">TO_CHAR</span><span class="p">(</span><span class="n">v_rowset</span><span class="p">(</span><span class="n">p_col_index</span><span class="p">).</span><span class="n">tab_date</span><span class="p">(</span><span class="n">p_row_index</span><span class="p">),</span> <span class="n">v_conv_fmts</span><span class="p">(</span><span class="n">p_col_index</span><span class="p">).</span><span class="n">f</span><span class="p">)</span>
                                <span class="k">WHEN</span> <span class="n">DBMS_TF</span><span class="p">.</span><span class="n">type_interval_ym</span> <span class="kr">THEN</span> 
                                    <span class="nf">TO_CHAR</span><span class="p">(</span><span class="n">v_rowset</span><span class="p">(</span><span class="n">p_col_index</span><span class="p">).</span><span class="n">tab_interval_ym</span><span class="p">(</span><span class="n">p_row_index</span><span class="p">),</span> <span class="n">v_conv_fmts</span><span class="p">(</span><span class="n">p_col_index</span><span class="p">).</span><span class="n">f</span><span class="p">)</span>
                                <span class="k">WHEN</span> <span class="n">DBMS_TF</span><span class="p">.</span><span class="n">type_interval_ds</span> <span class="kr">THEN</span> 
                                    <span class="nf">TO_CHAR</span><span class="p">(</span><span class="n">v_rowset</span><span class="p">(</span><span class="n">p_col_index</span><span class="p">).</span><span class="n">tab_interval_ds</span><span class="p">(</span><span class="n">p_row_index</span><span class="p">),</span> <span class="n">v_conv_fmts</span><span class="p">(</span><span class="n">p_col_index</span><span class="p">).</span><span class="n">f</span><span class="p">)</span>
                            <span class="k">END</span>
                            <span class="p">,</span> <span class="o">'</span><span class="s1">"</span><span class="o">'</span><span class="p">,</span> <span class="o">'</span><span class="se">\\</span><span class="s1">"</span><span class="o">'</span>
                        <span class="p">)</span> <span class="c1">-- backwack the dquotes if any</span>
                        <span class="o">||'</span><span class="s1">"</span><span class="o">'</span>
                    <span class="kr">ELSE</span>
                        <span class="n">DBMS_TF</span><span class="p">.</span><span class="n">col_to_char</span><span class="p">(</span><span class="n">v_rowset</span><span class="p">(</span><span class="n">p_col_index</span><span class="p">),</span> <span class="n">p_row_index</span><span class="p">)</span>
                <span class="k">END</span><span class="p">;</span>
            <span class="k">IF</span> <span class="nf">SUBSTR</span><span class="p">(</span><span class="n">v_s</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span> <span class="o">!=</span> <span class="o">'</span><span class="s1">"</span><span class="o">'</span> <span class="ow">AND</span> <span class="nf">INSTR</span><span class="p">(</span><span class="n">v_s</span><span class="p">,</span><span class="n">p_separator</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span> <span class="kr">THEN</span>
                <span class="n">v_s</span> <span class="o">:=</span> <span class="o">'</span><span class="s1">"</span><span class="o">'||</span><span class="n">v_s</span><span class="o">||'</span><span class="s1">"</span><span class="o">'</span><span class="p">;</span>
            <span class="k">END</span> <span class="k">IF</span><span class="p">;</span>
            <span class="k">RETURN</span> <span class="n">v_s</span><span class="p">;</span>
        <span class="k">END</span><span class="p">;</span> <span class="c1">-- apply_cust_conv</span>
    <span class="k">BEGIN</span>
</code></pre></div></div><p>The custom conversion code is a bit ugly. The default conversion to char provided by <em>DBMS_TF.col_to_char()</em> is almost perfect. It takes care of putting strings into double quotes and backwacking any embedded double quotes. For Date and Interval conversions it will also place the results in double quotes; however, for those it depends on the default string coversions (which can be further muddied by NLS_DATE_FORMAT).<p>The other oddity can happen when NLS_NUMERIC_CHARACTERS employs a comma. If we encounter a separator character in an unquoted value, we quote it.<p>Other than the use of <em>DBMS_TF.col_to_char</em>, this is standard PL/SQL (though perhaps a bit ugly), so I’m not going to expand on what it does other than to say it converts Oracle types to strings in a user specified manner while meeting the quoting needs for CSV output.<p>Now with the main <em>fetch_rows</em> body:<div class="language-plsql highlighter-rouge"><div class="highlight"><pre class="highlight"><code>        <span class="k">IF</span> <span class="n">p_header_row</span> <span class="ow">IN</span> <span class="p">(</span><span class="o">'</span><span class="s1">Y</span><span class="o">'</span><span class="p">,</span><span class="o">'</span><span class="s1">y</span><span class="o">'</span><span class="p">)</span> <span class="kr">THEN</span>
            <span class="c1">-- We need to put out a header row, so we have to engage in replication_factor shenanigans.</span>
            <span class="c1">-- This is in case FETCH is called more than once. We get and put to the store</span>
            <span class="c1">-- the fetch count.</span>
            <span class="c1">-- get does not change value if not found in store so starts with our default 0 on first fetch call</span>
            <span class="n">DBMS_TF</span><span class="p">.</span><span class="n">xstore_get</span><span class="p">(</span><span class="o">'</span><span class="s1">v_fetch_pass</span><span class="o">'</span><span class="p">,</span> <span class="n">v_fetch_pass</span><span class="p">);</span> 
<span class="c1">--dbms_output.put_line('xstore_get: '||v_fetch_pass);</span>
        <span class="kr">ELSE</span>
            <span class="n">v_fetch_pass</span> <span class="o">:=</span> <span class="mi">1</span><span class="p">;</span> <span class="c1">-- we do not need a header column. this will double as the flag</span>
        <span class="k">END</span> <span class="k">IF</span><span class="p">;</span>
</code></pre></div></div><p>If we need to produce a header row, then we need to know whether this is the first fetch call or not. We use <em>xstore_get</em> here and <em>xstore_put</em> later to maintain our state between calls to <em>fetch_rows</em>. If we do not need a header row, set our flag variable to skip that.<div class="language-plsql highlighter-rouge"><div class="highlight"><pre class="highlight"><code>        <span class="c1">-- get the data for this fetch </span>
        <span class="n">DBMS_TF</span><span class="p">.</span><span class="n">get_row_set</span><span class="p">(</span><span class="n">v_rowset</span><span class="p">,</span> <span class="n">v_row_cnt</span><span class="p">,</span> <span class="n">v_col_cnt</span><span class="p">);</span>

        <span class="c1">-- set up for custom TO_CHAR conversions if requested for date and/or interval types</span>
        <span class="kr">FOR</span> <span class="n">i</span> <span class="ow">IN</span> <span class="mi">1</span><span class="o">..</span><span class="n">v_col_cnt</span>
        <span class="kr">LOOP</span>
            <span class="k">IF</span> <span class="p">(</span><span class="n">p_date_format</span> <span class="ow">IS</span> <span class="ow">NOT</span> <span class="ow">NULL</span> <span class="ow">AND</span> <span class="n">v_env</span><span class="p">.</span><span class="n">get_columns</span><span class="p">(</span><span class="n">i</span><span class="p">).</span><span class="n">type</span> <span class="o">=</span> <span class="n">DBMS_TF</span><span class="p">.</span><span class="n">type_date</span><span class="p">)</span>
            <span class="kr">THEN</span>
                <span class="n">v_conv_fmts</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="o">:=</span> <span class="n">t_conv_fmt</span><span class="p">(</span><span class="n">DBMS_TF</span><span class="p">.</span><span class="n">type_date</span><span class="p">,</span> <span class="n">p_date_format</span><span class="p">);</span>
            <span class="kr">ELSIF</span> <span class="n">p_interval_format</span> <span class="ow">IS</span> <span class="ow">NOT</span> <span class="ow">NULL</span> 
                <span class="ow">AND</span> <span class="n">v_env</span><span class="p">.</span><span class="n">get_columns</span><span class="p">(</span><span class="n">i</span><span class="p">).</span><span class="n">type</span> <span class="ow">IN</span> <span class="p">(</span><span class="n">DBMS_TF</span><span class="p">.</span><span class="n">type_interval_ym</span><span class="p">,</span> <span class="n">DBMS_TF</span><span class="p">.</span><span class="n">type_interval_ds</span><span class="p">)</span> 
            <span class="kr">THEN</span>
                <span class="n">v_conv_fmts</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="o">:=</span> <span class="n">t_conv_fmt</span><span class="p">(</span><span class="n">v_env</span><span class="p">.</span><span class="n">get_columns</span><span class="p">(</span><span class="n">i</span><span class="p">).</span><span class="n">type</span><span class="p">,</span> <span class="n">p_interval_format</span><span class="p">);</span>
            <span class="k">END</span> <span class="k">IF</span><span class="p">;</span>
        <span class="k">END</span> <span class="kr">LOOP</span><span class="p">;</span>
</code></pre></div></div><p>We obtain the resultset data for this fetch, the number of rows and the number of columns. We then set up the custom conversion configuration if needed. Note that <em>v_conv_fmts</em> is sparse and possibly empty.<div class="language-plsql highlighter-rouge"><div class="highlight"><pre class="highlight"><code>        <span class="k">IF</span> <span class="n">v_fetch_pass</span> <span class="o">=</span> <span class="mi">0</span> <span class="kr">THEN</span> <span class="c1">-- this is first pass and we need header row</span>
            <span class="c1">-- the first row of our output will get a header row plus the data row</span>
            <span class="n">v_repfac</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="o">:=</span> <span class="mi">2</span><span class="p">;</span>
            <span class="c1">-- the rest of the rows will be 1 to 1 on the replication factor</span>
            <span class="kr">FOR</span> <span class="n">i</span> <span class="ow">IN</span> <span class="mi">2</span><span class="o">..</span><span class="n">v_row_cnt</span>
            <span class="kr">LOOP</span>
                <span class="n">v_repfac</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="o">:=</span> <span class="mi">1</span><span class="p">;</span>
            <span class="k">END</span> <span class="kr">LOOP</span><span class="p">;</span>
            <span class="c1">-- these names are already double quoted and Oracle will not allow a doublequote inside a column alias</span>
            <span class="n">v_val_col</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="o">:=</span> <span class="n">v_env</span><span class="p">.</span><span class="n">get_columns</span><span class="p">(</span><span class="mi">1</span><span class="p">).</span><span class="n">name</span><span class="p">;</span>
            <span class="kr">FOR</span> <span class="n">j</span> <span class="ow">IN</span> <span class="mi">2</span><span class="o">..</span><span class="n">v_col_cnt</span>
            <span class="kr">LOOP</span>
                <span class="n">v_val_col</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="o">:=</span> <span class="n">v_val_col</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="o">||</span><span class="n">p_separator</span><span class="o">||</span><span class="n">v_env</span><span class="p">.</span><span class="n">get_columns</span><span class="p">(</span><span class="n">j</span><span class="p">).</span><span class="n">name</span><span class="p">;</span> <span class="c1">--join the column names with ,</span>
            <span class="k">END</span> <span class="kr">LOOP</span><span class="p">;</span>
            <span class="n">v_out_row_i</span> <span class="o">:=</span> <span class="mi">1</span><span class="p">;</span>
<span class="c1">--dbms_output.put_line('header row: '||v_val_col(1));</span>
        <span class="k">END</span> <span class="k">IF</span><span class="p">;</span>
        <span class="c1">-- otherwise v_out_row_i is 0</span>
</code></pre></div></div><p>On the first fetch and only when we need to produce a header row, we set up our replication factor table. As stated above we want two output rows for the first input row, then one each for all the others.<p>We build the header row by joining the column names with the separator character (comma most likely).<p>Next we loop through the input rows building the corresponding output column (we only output a single column!).<div class="language-plsql highlighter-rouge"><div class="highlight"><pre class="highlight"><code>        <span class="kr">FOR</span> <span class="n">i</span> <span class="ow">IN</span> <span class="mi">1</span><span class="o">..</span><span class="n">v_row_cnt</span>
        <span class="kr">LOOP</span>
            <span class="n">v_out_row_i</span> <span class="o">:=</span> <span class="n">v_out_row_i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
            <span class="c1">-- concatenate the string representations of columns with ',' separator</span>
            <span class="c1">-- into a single column for output on this row.</span>
            <span class="c1">-- col_to_char() conveniently surrounds the character representation</span>
            <span class="c1">-- of non-numeric fields with double quotes. If there is a double quote in</span>
            <span class="c1">-- that data it will backwack it. Newlines in the field are passed through unchanged.</span>
            <span class="n">v_val_col</span><span class="p">(</span><span class="n">v_out_row_i</span><span class="p">)</span> <span class="o">:=</span> <span class="n">apply_cust_conv</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span> <span class="c1">--DBMS_TF.col_to_char(v_rowset(1), i);</span>
            <span class="kr">FOR</span> <span class="n">j</span> <span class="ow">IN</span> <span class="mi">2</span><span class="o">..</span><span class="n">v_col_cnt</span>
            <span class="kr">LOOP</span>
                <span class="n">v_val_col</span><span class="p">(</span><span class="n">v_out_row_i</span><span class="p">)</span> <span class="o">:=</span> <span class="n">v_val_col</span><span class="p">(</span><span class="n">v_out_row_i</span><span class="p">)</span><span class="o">||</span><span class="n">p_separator</span><span class="o">||</span><span class="n">apply_cust_conv</span><span class="p">(</span><span class="n">j</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span> <span class="c1">--DBMS_TF.col_to_char(v_rowset(j), i);</span>
            <span class="k">END</span> <span class="kr">LOOP</span><span class="p">;</span>
        <span class="k">END</span> <span class="kr">LOOP</span><span class="p">;</span>
</code></pre></div></div><p>If we generated a header row on this pass we submit our <em>replication_factor</em> table, then store our state for the next fetch pass.<div class="language-plsql highlighter-rouge"><div class="highlight"><pre class="highlight"><code>        <span class="k">IF</span> <span class="n">p_header_row</span> <span class="ow">IN</span> <span class="p">(</span><span class="o">'</span><span class="s1">Y</span><span class="o">'</span><span class="p">,</span><span class="o">'</span><span class="s1">y</span><span class="o">'</span><span class="p">)</span> <span class="kr">THEN</span>    <span class="c1">-- save for possible next fetch call</span>
            <span class="k">IF</span> <span class="n">v_fetch_pass</span> <span class="o">=</span> <span class="mi">0</span> <span class="kr">THEN</span>
                <span class="c1">-- only on the first fetch </span>
                <span class="n">DBMS_TF</span><span class="p">.</span><span class="n">row_replication</span><span class="p">(</span><span class="n">replication_factor</span> <span class="o">=&gt;</span> <span class="n">v_repfac</span><span class="p">);</span>
            <span class="k">END</span> <span class="k">IF</span><span class="p">;</span>
            <span class="n">v_fetch_pass</span> <span class="o">:=</span> <span class="n">v_fetch_pass</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
            <span class="n">DBMS_TF</span><span class="p">.</span><span class="n">xstore_set</span><span class="p">(</span><span class="o">'</span><span class="s1">v_fetch_pass</span><span class="o">'</span><span class="p">,</span> <span class="n">v_fetch_pass</span><span class="p">);</span>
        <span class="k">END</span> <span class="k">IF</span><span class="p">;</span>
        <span class="c1">-- otherwies we did not do any replication and will get one for one with input rows</span>
</code></pre></div></div><p>Notice that if we did not output a header row on this pass, we do not call <em>DBMS_TF.row_replication</em>.<p>And finally we tell the engine about our single output column collection.<div class="language-plsql highlighter-rouge"><div class="highlight"><pre class="highlight"><code>        <span class="n">DBMS_TF</span><span class="p">.</span><span class="n">put_col</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">v_val_col</span><span class="p">);</span>

    <span class="k">END</span> <span class="n">fetch_rows</span><span class="p">;</span>
</code></pre></div></div><h2 id="example-usage">Example Usage</h2><p>An example including an ORDER BY clause for the PTF input:<div class="language-plsql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kr">WITH</span> <span class="n">R</span> <span class="kr">AS</span> <span class="p">(</span>
    <span class="kr">SELECT</span> <span class="n">last_name</span><span class="o">||'</span><span class="s1">, </span><span class="o">'||</span><span class="n">first_name</span> <span class="kr">AS</span> <span class="o">"</span><span class="nv">Employee Name</span><span class="o">"</span><span class="p">,</span> <span class="n">hire_date</span> <span class="kr">AS</span> <span class="o">"</span><span class="nv">Hire Date</span><span class="o">"</span><span class="p">,</span> <span class="n">employee_id</span> <span class="kr">AS</span> <span class="o">"</span><span class="nv">Employee ID</span><span class="o">"</span>
    <span class="kr">FROM</span> <span class="n">hr</span><span class="p">.</span><span class="n">employees</span>
    <span class="c1">--ORDER BY last_name, first_name</span>
<span class="p">)</span> <span class="kr">SELECT</span> <span class="o">*</span>
<span class="kr">FROM</span> <span class="n">app_csv_pkg</span><span class="p">.</span><span class="n">ptf</span><span class="p">(</span><span class="n">R</span> <span class="kr">ORDER</span> <span class="kr">BY</span> <span class="p">(</span><span class="o">"</span><span class="nv">Employee Name</span><span class="o">"</span><span class="p">,</span> <span class="o">"</span><span class="nv">Hire Date</span><span class="o">"</span><span class="p">)</span>
                        <span class="p">,</span> <span class="n">p_date_format</span> <span class="o">=&gt;</span> <span class="o">'</span><span class="s1">YYYYMMDD</span><span class="o">'</span>
                    <span class="p">)</span>
<span class="kr">WHERE</span> <span class="k">rownum</span> <span class="o">&lt;=</span> <span class="mi">10</span>
<span class="p">;</span>
</code></pre></div></div><p>Output (notice how the header row counts as one of the 10 rows! It is just a data record in the resultset.):<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>"Employee Name","Hire Date","Employee ID"
"Abel, Ellen","20040511",174
"Ande, Sundar","20080324",166
"Atkinson, Mozhe","20051030",130
"Austin, David","20050625",105
"Baer, Hermann","20020607",204
"Baida, Shelli","20051224",116
"Banda, Amit","20080421",167
"Bates, Elizabeth","20070324",172
"Bell, Sarah","20040204",192
</code></pre></div></div><h2 id="conclusion">Conclusion</h2><p>The package implementation at <a href="https://github.com/lee-lindley/plsql_utilities#app_csv_pkg">PLSQL_utilities library</a> adds two <em>get_clob</em> functions and two <em>write_file</em> procedures that can be passed either a CURSOR (that is expected to end with a call to SELECT * FROM app_csv_pkg.ptf(…), or a SQL string CLOB that does the same.<p>This implementation has almost as much functionality as my original Object Oriented version that uses <em>DBMS_SQL</em>, but with a LOT less code. I think this version is also easier to understand once you get over the shock and awe around learning about Polymorphic Table Functions. I hope this article reduces the impact of that flash bang.</div></div><div class="panel-body"><h4>Related Posts</h4><ul><li class="relatedPost"> <a href="https://lee-lindley.github.io/oracle/plsql/sql/vim/2022/04/29/vim-plsql-syntax.html">Syntax Highlighting for PL/SQL in vim</a> (Categories: <a href="/category/oracle">oracle</a>, <a href="/category/plsql">plsql</a>, <a href="/category/sql">sql</a>, <a href="/category/vim">vim</a>)<li class="relatedPost"> <a href="https://lee-lindley.github.io/oracle/perl/linux/2022/04/28/Perl-DBD-Oracle-RHL.html">Intalling Perl DBD::Oracle on RHL</a> (Categories: <a href="/category/oracle">oracle</a>, <a href="/category/perl">perl</a>, <a href="/category/linux">linux</a>)<li class="relatedPost"> <a href="https://lee-lindley.github.io/oracle/sql/plsql/2022/04/10/hierarchical-profiler-context-switch.html">Profiling PL/SQL to Examine Context Switch Penalty</a> (Categories: <a href="/category/oracle">oracle</a>, <a href="/category/sql">sql</a>, <a href="/category/plsql">plsql</a>)<li class="relatedPost"> <a href="https://lee-lindley.github.io/oracle/sql/plsql/2022/04/10/Regexp_instr-Beginning-of-line-anchor.html">Oracle REGEXP_INSTR and Beginning of Line Anchor</a> (Categories: <a href="/category/oracle">oracle</a>, <a href="/category/sql">sql</a>, <a href="/category/plsql">plsql</a>)<li class="relatedPost"> <a href="https://lee-lindley.github.io/oracle/sql/plsql/2022/04/02/Object-Methods-in-SQL.html">Cost of UDT Object Methods in SQL</a> (Categories: <a href="/category/oracle">oracle</a>, <a href="/category/sql">sql</a>, <a href="/category/plsql">plsql</a>)<li class="relatedPost"> <a href="https://lee-lindley.github.io/plsql/sql/oracle/2022/03/28/Devops-Oracle-Deploy.html">Devops Data Deployment for Oracle</a> (Categories: <a href="/category/plsql">plsql</a>, <a href="/category/sql">sql</a>, <a href="/category/oracle">oracle</a>)</ul></div><div class="PageNavigation"> <a class="prev" href="/oracle/sql/plsql/2021/12/28/Polymorphic-Table-Function-for-CSV-2.html">&laquo; Polymorphic Table Function for CSV (take 2)</a> <a class="next" href="/oracle/plsql/perl/2022/01/02/Perl-Like-Operations-PLSQL.html">Perl Like Operations in PL/SQL &raquo;</a></div><div class="disqus-comments"><div id="disqus_thread"></div><script type="text/javascript"> /* <![CDATA[ */ var disqus_shortname = "leelindleyscratchpad"; var disqus_identifier = "https://lee-lindley.github.io_Polymorphic Table Function (PTF) for CSV (take 3)"; var disqus_title = "Polymorphic Table Function (PTF) for CSV (take 3)"; /* * * DON'T EDIT BELOW THIS LINE * * */ (function() { var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true; dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js'; (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq); })(); /* ]]> */ </script></div><footer> &copy; Lee Lindley - <a href="https://github.com/lee-lindley">https://github.com/lee-lindley</a> - Powered by Jekyll.<div class="btn-github" style="float:right;"> <iframe src="https://ghbtns.com/github-btn.html?user=agusmakmun&repo=agusmakmun.github.io&type=star&count=true" frameborder="0" scrolling="0" width="100" height="20px"></iframe> <iframe src="https://ghbtns.com/github-btn.html?user=agusmakmun&repo=agusmakmun.github.io&type=fork&count=true" frameborder="0" scrolling="0" width="100" height="20px"></iframe></div></footer></div></div><script src="//ajax.googleapis.com/ajax/libs/jquery/1.11.0/jquery.min.js"></script> <script src="//code.jquery.com/jquery-migrate-1.2.1.min.js"></script> <script src="/static/js/bootstrap.min.js"></script> <script src="/static/js/super-search.js"></script> <script src="/static/js/thickbox-compressed.js"></script> <script src="/static/js/projects.js"></script>
