<!DOCTYPE html><html><head><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="shortcut icon" href="/static/img/favicon.ico" /><title>Manipulating XLSX Spreadsheets in PL/SQL - Lee Lindley Scratchpad</title><meta name="author" content="Lee Lindley" /><meta name="description" content="Manipulating XLSX Spreadsheets in PL/SQL" /><meta name="keywords" content="Manipulating XLSX Spreadsheets in PL/SQL, Lee Lindley Scratchpad, oracle, plsql" /><link rel="alternate" type="application/rss+xml" title="RSS" href="/feed.xml"><meta content="" property="fb:app_id"><meta content="Lee Lindley Scratchpad" property="og:site_name"><meta content="Manipulating XLSX Spreadsheets in PL/SQL" property="og:title"><meta content="article" property="og:type"><meta content="Posts on Technical Subjects, mostly Oracle and Linux" property="og:description"><meta content="https://lee-lindley.github.io/oracle/plsql/2022/09/18/spreadsheets_with_plsql.html" property="og:url"><meta content="2022-09-18T07:30:00-04:00" property="article:published_time"><meta content="https://lee-lindley.github.io/about/" property="article:author"><meta content="oracle" property="article:section"><meta content="oracle" property="article:tag"><meta content="plsql" property="article:tag"><meta name="twitter:card" content="summary"><meta name="twitter:site" content="@"><meta name="twitter:creator" content="@"><meta name="twitter:title" content="Manipulating XLSX Spreadsheets in PL/SQL"><meta name="twitter:url" content="https://lee-lindley.github.io/oracle/plsql/2022/09/18/spreadsheets_with_plsql.html"><meta name="twitter:description" content="Posts on Technical Subjects, mostly Oracle and Linux"><link href="/static/css/font-awesome.min.css" rel="stylesheet" integrity="sha384-T8Gy5hrqNKT+hzMclPo118YTQO6cYprQmhrYwIiQ/3axmI1hQomh7Ud2hPOy8SP1" crossorigin="anonymous"><link rel="stylesheet" href="/static/css/syntax.css"><link href="/static/css/bootstrap.min.css" rel="stylesheet"><link href="https://fonts.googleapis.com/css?family=Roboto+Condensed:400,300italic,300,400italic,700&amp;subset=latin,latin-ext" rel="stylesheet" type="text/css"><link rel="stylesheet" href="/static/css/super-search.css"><link rel="stylesheet" href="/static/css/thickbox.css"><link rel="stylesheet" href="/static/css/projects.css"><link rel="stylesheet" href="/static/css/main.css"><body><div class="container"><div class="col-sm-3"><div class="fixed-condition"><h1 class="author-name"><a href="/">Lee Lindley</a></h1><div class="profile-about"> I'm Just Another Perl Hacker who wound up in a big Oracle Database playground</div><div class="social"><ul><li><a href="https://linkedin.com/in/lee-lindley" target="_blank"><i class="fa fa-linkedin"></i></a><li><a href="https://github.com/lee-lindley" target="_blank"><i class="fa fa-github"></i></a></ul></div><div class="search" id="js-search"> <input type="text" placeholder="(sitemap)~$ type to search" class="search__input form-control" id="js-search__input"><ul class="search__results" id="js-search__results"></ul></div><hr /><ul class="sidebar-nav"> <strong>Navigation</strong><li><a href="/">Home</a><li><a class="about" href="/about/">About Me</a><li><a class="about" href="/projects/">My Projects</a><li><a class="about" href="/feed.xml">XML Feed</a></ul></div></div><div class="col-sm-8 col-offset-1 main-layout"><header class="post-header"><h1 class="post-title">Manipulating XLSX Spreadsheets in PL/SQL</h1></header><span class="time">18 Sep 2022</span> <span class="categories"> &raquo; <a href="/category/oracle">oracle</a>, <a href="/category/plsql">plsql</a> </span><div class="content"><div class="post"><h1 id="introduction">Introduction</h1><p>There are many common methods for inputting and outputting spreadsheet data from Oracle. Below are two limited lists for talking purposes. You may well have others.<p>Our use case is to supplement the data in a user maintained spreadsheet using data from an Oracle database. We must as faithfully as possible maintain the existing data in the spreadsheet while adding new columns.<table class="img-table-centered"><thead><tr><th style="text-align: center"><em>app_read_xlsx_udt Use Case Diagram</em><tbody><tr><td style="text-align: center"><img src="/images/spreadsheet_input_use_case.gif" alt="" /></table><p>One limitation shared by common XLSX/Oracle methods is the concept that a column may contain only one datatype. A date column contains only dates or NULLs. A numeric column contains only numbers or NULLS. Yet, spreadsheet data cells may contain any kind of data and formatting can be specific to the cell. We traditionally think of columns in the spreadsheet of being a single datatype and formatting is typically accomplished at the column level, but our intrepid business user may place a string such as “Terminated” or “N/A” in a column that otherwise has Date values.<p>If we were tasked with replacing their entire business process, we would of course normalize this data and separate the non-date content into a separate column; however, our short term task is to supplement the data the business uses in an existing process. We do not control their process or their data.<p><strong>How can we maintain the polymorphic cell content of the spreadsheet and replicate it on output?</strong><h1 id="content">Content</h1><ul><li><a href="#example-methods-for-manipulating-xlsx-with-oracle">Example Methods for Manipulating XLSX with Oracle</a><ul><li><a href="#input-spreadsheet-to-oracle">Input Spreadsheet to Oracle</a><li><a href="#output-spreadsheet-from-oracle">Output Spreadsheet from Oracle</a></ul><li><a href="#option-elimination">Option Elimination</a><ul><li><a href="#a-microsoft-option">A Microsoft Option</a><li><a href="#oracle-specific-options">Oracle Specific Options</a></ul><li><a href="#excelgen-and-anydata-columns">ExcelGen and ANYDATA Columns</a><li><a href="#app_read_xlsx">app_read_xlsx</a><ul><li><a href="#overview">Overview</a><li><a href="#considerations">Considerations</a><li><a href="#technique">Technique</a><li><a href="#code-dive">Code Dive</a></ul><li><a href="#conclusion">Conclusion</a></ul><h1 id="example-methods-for-manipulating-xlsx-with-oracle">Example Methods for Manipulating XLSX with Oracle</h1><h2 id="input-spreadsheet-to-oracle">Input Spreadsheet to Oracle</h2><ul><li>An ODBC connection from Excel to insert spreadsheet content into Oracle table - perhaps using a VB Macro<li>Save as CSV and load with external table or sqlldr<li>Toad, SQL Developer or other client tool to read xlsx and extract into an Oracle table<li>An ETL tool like Informatica which can read XLSX<li>A PL/SQL tool that can parse XLSX such as <a href="https://technology.amis.nl/languages/oracle-plsql/read-a-excel-xlsx-with-plsql/">Anton Scheffer’s as_read_xlsx</a> or <a href="https://github.com/mbleron/ExcelTable">Marc Bleron’s ExcelTable</a>.</ul><h2 id="output-spreadsheet-from-oracle">Output Spreadsheet from Oracle</h2><ul><li>An ODBC connection from Excel to read a query resultset - perhaps using a VB Macro<li>Output a CSV text file from Oracle and open with Excel<li>Toad, SQL Developer or other client tool generate an XLSX file from a query resultset<li>An ETL tool like Informatica which can generate XLSX<li>A PL/SQL tool to generate XLSX directly in the database like <a href="https://github.com/mbleron/ExcelGen">Marc Bleron’s ExcelGen</a><li>Python xlsxwriter</ul><h1 id="option-elimination">Option Elimination</h1><h2 id="a-microsoft-option">A Microsoft Option</h2><p>The most full featured option for this use case is the Microsoft Excel library available from Visual Basic or C#. One can create a macro directly inside the spreadsheet using an ODBC connection to the database to perform the task. Limitations are:<ul><li>The user’s personal Oracle login must have access to all needed queries and functions. Since the user’s personal login is not tracked as an IT asset, care must be taken to encapsulate all necessary access via appropriate roles. Even so, maintenance of user accounts and associating the correct roles to include access needed by this spreadsheet becomes a burden.<li>The code lives on a User’s desktop or maybe a shared drive. Perhaps the gold copy could be kept under source code control and made available to the users, but it doesn’t really fit well with common SDLC practices. The business could also change the spreadsheet parts that are not related to the data pull. At that point it is out of sync with the IT maintained copy.<li>When the user experiences problems, the first thing IT must question is whether the user is employing the latest version of the code.<li>The expertise to perform this task, though not uncommon, is not necessarily in the toolbox for a journeyman Oracle developer.</ul><p>An extension of this option may be to use a Sql Server database (or whatever it is called now) to host the operation on the spreadsheet. I have not done this and do not know limitations, but my understanding is these Excel libraries should be available to code that is run from the database. DBLink accounts that can connect to the Oracle database can be maintained for this server and the code can be put under source code control. This added complexity does not appeal to me, but a shop who already run Sql Server databases, especially those supporting batch operations and/or existing user interaction screens that include file transfer may favor this option.<h2 id="oracle-specific-options">Oracle Specific Options</h2><p>As mentioned, most of the listed options stumble when faced with a column that can contain cells with different data types. We can reduce everything to text, but then when we output to a spreadsheet again, we’ve lost information and our business partner is not pleased. This eliminates using CSV or a client like Toad, SqlDeveloper or Informatica to deliver the data to the database.<p><strong>We are left with <em>as_read_xlsx</em> or <em>ExcelTable</em> for the input, both of which can deliver the raw spreadsheet data at the cell level with data type intact.</strong><p>Assuming we can maintain the polymorphic content information about individual cells on input, we face the same limitation on output. A tool like Toad, SQL Developer or Informatica reads resultsets from queries. I do not believe any of them have been enhanced to support the Oracle <em>ANYDATA</em> object type so we are restricted to cell data that is either character, date or number.<p>I mention Python xlsxwriter, but I really don’t know if it has such a capability. What I have seen of it in practice is that it takes a resultset from a query similarly to the others.<p>I set up this straw man with a non-exhaustive list of options, so there may well be another choice out there. I would love to hear about it if so. The choice I made is to <strong>use <em>ExcelGen</em> to create the output spreadsheet.</strong><p>Of the two possible input tools, <em>ExcelTable</em> is more sophisticated and already supports providing the raw cell data as <em>ANYDATA</em> values. It has other functions that return <em>ANYDATASET</em> results which is fantastic, but these require you to provide the column type and header information in your code. I badly wanted to use the first row of the spreadsheet for the column headers and do not want to specify the data type. I considered adding functionality to do so, but was not encouraged. Perhaps I did not sell it well enough.<p>Although I wanted to use <em>ExcelTable</em>, the more I looked into it the bigger the sinking feeling I had that it was beyond a level of complexity I felt I could leave with my employer. Without community support it was not an option.<p>By process of elimination we are left with <em>as_read_xlsx</em> which is a perfectly serviceable tool that is in widespread use.<h1 id="excelgen-and-anydata-columns">ExcelGen and ANYDATA Columns</h1><p>The currently published version of <em>ExcelGen</em> does not support <em>ANYDATA</em> data type input columns. I created a fork and Pull Request adding this functionality, but was not aware that Marc was in the midst of a refactor/redesign of <em>ExcelGen</em> and he politely declined the PR. He agreed that allowing <em>ANYDATA</em> input columns was useful and he liked the idea of supporting it. I’ll call that a soft commitment. If the next version of <em>ExcelGen</em> does not support <em>ANYDATA</em> input, I’ll create another pull request to add it. I’m fairly confident it will be included in a future release one way or another.<p>Meanwhile, to implement the solution discussed here you will need to use <a href="https://github.com/lee-lindley/ExcelGen/tree/anydata">my forked version of ExcelGen</a>.<h1 id="app_read_xlsx">app_read_xlsx</h1><p>Although it uses <em>as_read_xlsx</em> as the underlying workhorse, <a href="https://github.com/lee-lindley/app_read_xlsx">app_read_xlsx</a> takes care of many of the details needed to treat a spreadsheet as a row source, using the first row data values as the column names and output column headers.<p>The documentation found in the README.md at the above link discusses some of what is covered in this article. It also contains what I think is a decent example showing the problem and the solution. I am not going to repeat those here but am going to borrow the <em>How it Works</em> section from that document.<h2 id="overview">Overview</h2><ul><li>The input datastream from <em>as_read_xlsx</em> is a table of cell data. The ordinal row and column numbers of the spreadsheet are columns/attributes in this data stream.<li>Empty cells are not present in the data.<li>The concept of column headers and database identifiers for the columns is not present in this structure.<li>Each cell is represented with a polymorphic structure containing a <em>cell_type</em> attribute and a value in one of the attributes <em>string_val</em>, <em>number_val</em>, <em>date_val</em>, <em>formula</em>. <em>formula</em> is out of scope for this implementation. Our design pattern converts this polymorphic structure into an Oracle <em>ANYDATA</em> object type.</ul><p>Presenting the cell data in a two dimensional standard database pattern requires<ul><li>extract column identifiers and number of columns from the first row of the input data<li>pivot spreadsheet columns into rows<li>densify the missing/empty cells<li>convert multi-attribute polymorphic cell representation into <em>ANYDATA</em> objects<li>present the <em>ANYDATA</em> cell objects in standard database TABLE structure with rows and columns named from the spreadsheet column headers</ul><p>Doing this requires a runtime determination of the resultset type. It is not difficult to do this for a PL/SQL cursor as we can use a weakly typed SYS_REFCURSOR. It is much harder to present the results to the SQL engine in a way that the resultset may be joined and extended.<h2 id="considerations">Considerations</h2><p>When one hears the term <strong>polymorphic resultset</strong>, we instantly turn to the cool new Oracle toy (well, new as of Oracle 18c) of <strong>Polymorphic Table Functions</strong>. Unfortunately, this design pattern only supports standard Oracle datatypes. Object types such as <em>ANYDATA</em> are not supported, at least as of Oracle 19c.<p>Another method for achieving this is the <strong>ANYDATASET</strong> technique which is built with <strong>ANYTYPE</strong>. Building these requires producing ODCI level code, whether in PL/SQL or another compiled language such as Java or C. Although this pattern can be followed reasonably well at a cookbook level for standard data types with a moderate level of study, extending it to handle piece-wise construction of complex object types such as the <em>ANYDATA</em> objects is non-trivial. (see <em>ExcelTable.getRows</em> in <a href="https://github.com/mbleron/ExcelTable">ExcelTable</a> for an example of using <strong>ANYDATASET</strong> with standard datatypes.) This is a level of complexity the author has seldom observed within most corporate IT departments. If there were community support of this I would be willing, but for this project it exceeds the complexity level with which I’m comfortable encumbering my current employer.<p>The level of complexity I settled on was using a compile time known object type representing a row, and standard pipelined table function returning a collection of that row object type. This is a well known and documented technique that should be in the wheelhouse of most journeyman level Oracle practitioners. The only slightly tricky part I added was the use of a nested table collection inside this object and an object method named <strong>get</strong> for extracting members of that nested table in a SQL statement.<h2 id="technique">Technique</h2><p>We start with a collection object type of <em>ANYDATA</em> objects.<div class="language-plsql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kr">CREATE</span> <span class="kr">OR</span> <span class="kr">REPLACE</span> <span class="kr">TYPE</span> <span class="n">arr_anydata_udt</span> <span class="k">FORCE</span> <span class="kr">AS</span> <span class="kr">TABLE</span> <span class="kr">OF</span> <span class="n">sys</span><span class="p">.</span><span class="n">anydata</span><span class="p">;</span>
<span class="o">/</span>
</code></pre></div></div><p>Next we build an object type that can be piped from our table function:<div class="language-plsql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kr">CREATE</span> <span class="kr">OR</span> <span class="kr">REPLACE</span> <span class="kr">TYPE</span> <span class="n">app_read_xlsx_row_udt</span> <span class="k">FORCE</span> <span class="kr">AS</span> <span class="k">OBJECT</span> <span class="p">(</span>
    <span class="n">data_row_nr</span> <span class="kt">NUMBER</span>
    <span class="p">,</span><span class="n">aa</span>         <span class="n">arr_anydata_udt</span>
    <span class="p">,</span><span class="k">MEMBER</span> <span class="k">FUNCTION</span> <span class="k">get</span><span class="p">(</span><span class="n">p_i</span> <span class="kt">NUMBER</span><span class="p">)</span> <span class="k">RETURN</span> <span class="n">SYS</span><span class="p">.</span><span class="n">anydata</span>
<span class="p">);</span>
<span class="o">/</span>
<span class="kr">CREATE</span> <span class="kr">OR</span> <span class="kr">REPLACE</span> <span class="kr">TYPE</span> <span class="kr">BODY</span> <span class="n">app_read_xlsx_row_udt</span> <span class="kr">AS</span>
    <span class="k">MEMBER</span> <span class="k">FUNCTION</span> <span class="k">get</span><span class="p">(</span><span class="n">p_i</span> <span class="kt">NUMBER</span><span class="p">)</span>
    <span class="k">RETURN</span> <span class="n">SYS</span><span class="p">.</span><span class="n">anydata</span>
    <span class="kr">AS</span>
    <span class="k">BEGIN</span>
        <span class="k">RETURN</span> <span class="n">aa</span><span class="p">(</span><span class="n">p_i</span><span class="p">);</span>
    <span class="k">END</span> <span class="k">get</span><span class="p">;</span>
<span class="k">END</span><span class="p">;</span>
<span class="o">/</span>
</code></pre></div></div><p>The <em>get</em> method is necessary to access a member of the nested table collection from within SQL (inside PL/SQL you could just use aa(i)).<p>Then to be able to define our pipelined table function we need a nested table type of these elements:<div class="language-plsql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kr">CREATE</span> <span class="kr">OR</span> <span class="kr">REPLACE</span> <span class="kr">TYPE</span> <span class="n">arr_app_read_xlsx_row_udt</span> <span class="k">FORCE</span> <span class="kr">AS</span> <span class="kr">TABLE</span> <span class="kr">OF</span> <span class="n">app_read_xlsx_row_udt</span><span class="p">;</span>
<span class="o">/</span>
</code></pre></div></div><p>Our pipelined table function (which is a static method of our main object type <em>app_read_xlsx_udt</em>) can then be declared as:<div class="language-plsql highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="k">STATIC</span> <span class="k">FUNCTION</span> <span class="n">get_data_rows</span><span class="p">(</span>
         <span class="n">p_ctx</span>      <span class="kt">NUMBER</span>
        <span class="p">,</span><span class="n">p_col_cnt</span>  <span class="kt">NUMBER</span>
    <span class="p">)</span> <span class="k">RETURN</span> <span class="n">arr_app_read_xlsx_row_udt</span> <span class="kr">PIPELINED</span>
</code></pre></div></div><p>This still leaves the task of generating a SQL select list that turns the collection elements <em>aa.get(i)</em> into columns with an identifier based on the first row of the spreadsheet. That is done by calling the <em>get_sql</em> method of <em>app_read_xlsx_udt</em>. It builds a dynamic SQL statement for you that you can then use as part of a larger application level SQL statement as shown in the examples section and reproduced here.<div class="language-plsql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kr">SELECT</span> <span class="n">X</span><span class="p">.</span><span class="n">R</span><span class="p">.</span><span class="n">data_row_nr</span> <span class="kr">AS</span> <span class="n">data_row_nr</span><span class="p">,</span>
   <span class="n">X</span><span class="p">.</span><span class="n">R</span><span class="p">.</span><span class="n">get</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="kr">AS</span> <span class="o">"</span><span class="nv">id</span><span class="o">"</span>
    <span class="p">,</span><span class="n">X</span><span class="p">.</span><span class="n">R</span><span class="p">.</span><span class="n">get</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span> <span class="kr">AS</span> <span class="o">"</span><span class="nv">data</span><span class="o">"</span>
    <span class="p">,</span><span class="n">X</span><span class="p">.</span><span class="n">R</span><span class="p">.</span><span class="n">get</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span> <span class="kr">AS</span> <span class="o">"</span><span class="nv">ddata</span><span class="o">"</span>
  <span class="kr">FROM</span> <span class="p">(</span>
    <span class="kr">SELECT</span> <span class="nf">VALUE</span><span class="p">(</span><span class="n">t</span><span class="p">)</span> <span class="kr">AS</span> <span class="n">R</span> <span class="c1">-- full object, not the object members * would provide</span>
    <span class="kr">FROM</span> <span class="kr">TABLE</span><span class="p">(</span><span class="n">LEE</span><span class="p">.</span><span class="n">app_read_xlsx_udt</span><span class="p">.</span><span class="n">get_data_rows</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">))</span> <span class="n">t</span>
  <span class="p">)</span> <span class="n">X</span>
</code></pre></div></div><h2 id="code-dive">Code Dive</h2><p>The manual page for <em>app_read_xlsx_udt</em> constructor describes how the output from <em>as_read_xlsx</em> is read into a global temporary table (GTT). Subsequent reads of this data for the first row determine the number of columns and column headers to populate the object attributes during the constructor call. After that we read the row data from the GTT using the static pipelined table function <em>app_read_xlsx_udt.get_data_rows</em>.<p>This code is a little interesting in how it uses a restricted package ( ACCESSIBLE BY (app_read_xlsx_udt) ) to maintain a set of session specific context numbers allowing for multiple spreadsheets to be read simultaneously in a single session. The package also implements the call to <em>as_read_xlsx</em> when it populates the GTT. You can look at your leisure.<p>In <a href="@overview">Overview</a> we listed the tasks the function needed to perform in a bullet list. Most of these tasks are handled in the static pipelined table function <em>app_read_xlsx_udt.get_data_rows</em> via a cursor that uses a bind variable for the number of columns we have in our input (gathered during object constructor call).<p>These two bullet items are covered by the first code section:<ul><li>densify the missing/empty cells<li>convert multi-attribute polymorphic cell representation into ANYDATA objects</ul><p>First, generate a Common Table Expression (CTE or WITH Clause view) consisting of an integer for each column.<div class="language-plsql highlighter-rouge"><div class="highlight"><pre class="highlight"><code>        <span class="k">CURSOR</span> <span class="n">c_filled_gaps</span> <span class="kr">IS</span>
<span class="kr">WITH</span> <span class="n">cols</span> <span class="kr">AS</span> <span class="p">(</span>
    <span class="kr">SELECT</span> <span class="k">level</span> <span class="kr">AS</span> <span class="n">col_nr</span> <span class="kr">FROM</span> <span class="n">dual</span> <span class="kr">CONNECT</span> <span class="kr">BY</span> <span class="k">level</span> <span class="o">&lt;=</span> <span class="n">p_col_cnt</span>
<span class="p">)</span>
</code></pre></div></div><p>Next, grab our data from the GTT, but only the rows and columns of interest.<div class="language-plsql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">,</span> <span class="n">this_ctx_cols</span> <span class="kr">AS</span> <span class="p">(</span>
    <span class="kr">SELECT</span> <span class="n">row_nr</span><span class="p">,</span> <span class="n">col_nr</span><span class="p">,</span> <span class="n">cell_type</span><span class="p">,</span> <span class="n">string_val</span><span class="p">,</span> <span class="n">date_val</span><span class="p">,</span> <span class="n">number_val</span>
    <span class="kr">FROM</span> <span class="n">as_read_xlsx_gtt</span>
    <span class="kr">WHERE</span> <span class="n">ctx</span> <span class="o">=</span> <span class="n">p_ctx</span> <span class="ow">AND</span> <span class="n">row_nr</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="ow">AND</span> <span class="n">col_nr</span> <span class="o">&lt;=</span> <span class="n">p_col_cnt</span>
<span class="p">)</span>
</code></pre></div></div><p>The <em>CASE</em> statement below examines the data type of the cell and calls the appropriate static constructor for an <em>ANYDATA</em> object. Notice the funky method for creating a NULL <em>ANYDATA</em> object. If you find a less kludgey method, let me know.<p>The PARTITION BY and RIGHT OUTER JOIN are an Oracle technique I do not know the name of for densifying data. Heck, that could be the official name of the technique. It makes sure that on any given <em>row_nr</em> we selected from the GTT, there <strong>will</strong> be a row in the output for every column.<div class="language-plsql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">,</span> <span class="n">ad_cols</span> <span class="kr">AS</span> <span class="p">(</span>
    <span class="kr">SELECT</span> <span class="n">t</span><span class="p">.</span><span class="n">row_nr</span><span class="p">,</span> <span class="n">cols</span><span class="p">.</span><span class="n">col_nr</span>
        <span class="p">,</span><span class="k">CASE</span> <span class="n">t</span><span class="p">.</span><span class="n">cell_type</span>
            <span class="k">WHEN</span> <span class="o">'</span><span class="s1">S</span><span class="o">'</span> <span class="kr">THEN</span> <span class="n">SYS</span><span class="p">.</span><span class="n">ANYDATA</span><span class="p">.</span><span class="n">convertVarchar2</span><span class="p">(</span><span class="n">t</span><span class="p">.</span><span class="n">string_val</span><span class="p">)</span>
            <span class="k">WHEN</span> <span class="o">'</span><span class="s1">D</span><span class="o">'</span> <span class="kr">THEN</span> <span class="n">SYS</span><span class="p">.</span><span class="n">ANYDATA</span><span class="p">.</span><span class="n">convertDate</span><span class="p">(</span><span class="n">t</span><span class="p">.</span><span class="n">date_val</span><span class="p">)</span>
            <span class="k">WHEN</span> <span class="o">'</span><span class="s1">N</span><span class="o">'</span> <span class="kr">THEN</span> <span class="n">SYS</span><span class="p">.</span><span class="n">ANYDATA</span><span class="p">.</span><span class="n">convertNumber</span><span class="p">(</span><span class="n">t</span><span class="p">.</span><span class="n">number_val</span><span class="p">)</span>
            <span class="kr">ELSE</span> <span class="n">SYS</span><span class="p">.</span><span class="n">ANYDATA</span><span class="p">.</span><span class="n">convertVarchar2</span><span class="p">(</span><span class="kr">NULL</span><span class="p">)</span> <span class="c1">-- must have a placeholder for collect</span>
        <span class="k">END</span> <span class="kr">AS</span> <span class="n">ad</span>
    <span class="kr">FROM</span> <span class="n">this_ctx_cols</span> <span class="n">t</span>
    <span class="k">PARTITION</span> <span class="kr">BY</span> <span class="p">(</span><span class="n">t</span><span class="p">.</span><span class="n">row_nr</span><span class="p">)</span> <span class="c1">-- fill gaps for empty cells</span>
    <span class="k">RIGHT</span> <span class="k">OUTER</span> <span class="k">JOIN</span> <span class="n">cols</span>
        <span class="kr">ON</span> <span class="n">cols</span><span class="p">.</span><span class="n">col_nr</span> <span class="o">=</span> <span class="n">t</span><span class="p">.</span><span class="n">col_nr</span>
<span class="p">)</span>
</code></pre></div></div><p>Now that we are promised a row for every cell, we can use a <em>COLLECT</em> aggregation function to build a nested table collection object in SQL. That takes care of pivoting the column data into a single row per spreadsheet row, if not exactly pivoting into columns yet.<ul><li>pivot spreadsheet columns into rows</ul><p>To complete the cursor query we plug these values into the default constructor for our <em>app_read_xlsx_row_udt</em> object described earlier. That is what our function must PIPE ROW out.<div class="language-plsql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">,</span> <span class="n">ad_arr</span> <span class="kr">AS</span> <span class="p">(</span>
    <span class="kr">SELECT</span> <span class="n">row_nr</span> <span class="o">-</span> <span class="mi">1</span> <span class="kr">AS</span> <span class="n">data_row_nr</span>
        <span class="p">,</span><span class="nf">CAST</span><span class="p">(</span> <span class="nf">COLLECT</span><span class="p">(</span><span class="n">ad</span> <span class="kr">ORDER</span> <span class="kr">BY</span> <span class="n">col_nr</span><span class="p">)</span> <span class="kr">AS</span> <span class="n">arr_anydata_udt</span><span class="p">)</span> <span class="kr">AS</span> <span class="n">vaa</span>
    <span class="kr">FROM</span> <span class="n">ad_cols</span>
    <span class="kr">GROUP</span> <span class="kr">BY</span> <span class="n">row_nr</span>
<span class="p">)</span>
<span class="kr">SELECT</span> <span class="n">app_read_xlsx_row_udt</span><span class="p">(</span><span class="n">data_row_nr</span><span class="p">,</span> <span class="n">vaa</span><span class="p">)</span>
<span class="kr">FROM</span> <span class="n">ad_arr</span>
<span class="p">;</span>
</code></pre></div></div><p>The rest of the function is simple boilerplate for a pipelined table function:<div class="language-plsql highlighter-rouge"><div class="highlight"><pre class="highlight"><code>        <span class="k">OPEN</span> <span class="n">c_filled_gaps</span><span class="p">;</span>
        <span class="kr">LOOP</span>
            <span class="k">FETCH</span> <span class="n">c_filled_gaps</span> <span class="k">BULK</span> <span class="nf">COLLECT</span> <span class="kr">INTO</span> <span class="n">v_arr</span> <span class="k">LIMIT</span> <span class="mi">100</span><span class="p">;</span>
            <span class="kr">EXIT</span> <span class="k">WHEN</span> <span class="n">v_arr</span><span class="p">.</span><span class="nf">COUNT</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
            <span class="kr">FOR</span> <span class="n">i</span> <span class="ow">IN</span> <span class="mf">1.</span><span class="p">.</span><span class="n">v_arr</span><span class="p">.</span><span class="nf">COUNT</span>
            <span class="kr">LOOP</span>
                <span class="kr">PIPE</span> <span class="k">ROW</span><span class="p">(</span><span class="n">v_arr</span><span class="p">(</span><span class="n">i</span><span class="p">));</span>
            <span class="k">END</span> <span class="kr">LOOP</span><span class="p">;</span>
        <span class="k">END</span> <span class="kr">LOOP</span><span class="p">;</span>
        <span class="k">CLOSE</span> <span class="n">c_filled_gaps</span><span class="p">;</span>
        <span class="k">RETURN</span><span class="p">;</span>
</code></pre></div></div><p>No matter how many columns we have or what our column names are, we have a single compile-time representation of our resultset coming from this pipelined table function. With a little help from member function <em>app_read_xlsx_udt.get_sql</em> we can get our columns out with proper names using regular SQL and use it as if it had come from a table.<p>You can look at the code for <em>get_sql</em> at your leisure, but the example shown in the <a href="#technique">Technique</a> section and repeated next is the best way to understand it:<div class="language-plsql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kr">SELECT</span> <span class="n">X</span><span class="p">.</span><span class="n">R</span><span class="p">.</span><span class="n">data_row_nr</span> <span class="kr">AS</span> <span class="n">data_row_nr</span><span class="p">,</span>
   <span class="n">X</span><span class="p">.</span><span class="n">R</span><span class="p">.</span><span class="n">get</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="kr">AS</span> <span class="o">"</span><span class="nv">id</span><span class="o">"</span>
    <span class="p">,</span><span class="n">X</span><span class="p">.</span><span class="n">R</span><span class="p">.</span><span class="n">get</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span> <span class="kr">AS</span> <span class="o">"</span><span class="nv">data</span><span class="o">"</span>
    <span class="p">,</span><span class="n">X</span><span class="p">.</span><span class="n">R</span><span class="p">.</span><span class="n">get</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span> <span class="kr">AS</span> <span class="o">"</span><span class="nv">ddata</span><span class="o">"</span>
  <span class="kr">FROM</span> <span class="p">(</span>
    <span class="kr">SELECT</span> <span class="nf">VALUE</span><span class="p">(</span><span class="n">t</span><span class="p">)</span> <span class="kr">AS</span> <span class="n">R</span> <span class="c1">-- full object, not the object members * would provide</span>
    <span class="kr">FROM</span> <span class="kr">TABLE</span><span class="p">(</span><span class="n">LEE</span><span class="p">.</span><span class="n">app_read_xlsx_udt</span><span class="p">.</span><span class="n">get_data_rows</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">))</span> <span class="n">t</span>
  <span class="p">)</span> <span class="n">X</span>
</code></pre></div></div><p>I’ll mention something that confounds those who have not used Oracle objects often. In order to access a member method or element of an object you must use a table alias as part of the name. One cannot rely on an actual table name or an implied (no) table name; it must be a table alias. In this case the table alias is ‘X’.<p>The other thing to mention is the use of the <em>VALUE</em> function. The most common way we extract data from a pipelined table function is via <em>SELECT *</em>. If we do that here, we will get the elements of the <em>app_read_xlsx_row_udt</em> object rather than the object itself. We need the <em>get</em> member method of the object, so it is important that we retrieve the object intact rather than the object elements. <em>VALUE</em> gives us the actual object returned from the pipelined table function rather than the object elements. It’s relatively obscure.<h1 id="conclusion">Conclusion</h1><p>This turned out to be a much harder problem than I thought it would be when I started. Limitations of <em>Polymorphic Table Functions</em> and the complexity of <em>ANYTYPE/ANYDATASET</em> took me off guard. It would have been easiest to craft one-off solutions for each spreadsheet by writing a custom cursor, but it felt like the wrong answer. Creating <em>app_read_xlsx</em> was the result. It is a bit messier than I would like in the way it gives you a SQL statement for your program to incorporate, but I feel it is an appropriate level of abstraction given the requirements and limitations.<p>Hope you find both the tool and the journey to get here helpful.</div></div><div class="panel-body"><h4>Related Posts</h4><ul><li class="relatedPost"> <a href="https://lee-lindley.github.io/oracle/sql/plsql/2022/11/24/Cursor_from_Collections.html">Create a PL/SQL Cursor from a Nested Table of Nested Tables</a> (Categories: <a href="/category/oracle">oracle</a>, <a href="/category/sql">sql</a>, <a href="/category/plsql">plsql</a>)<li class="relatedPost"> <a href="https://lee-lindley.github.io/oracle/perl/2022/11/13/version_db_objects.html">Versioning Oracle Code from Open Source</a> (Categories: <a href="/category/oracle">oracle</a>, <a href="/category/perl">perl</a>)<li class="relatedPost"> <a href="https://lee-lindley.github.io/oracle/sql/2022/10/09/antijoins_with_or.html">Tuning Query with OR Conditions in a NOT EXISTS</a> (Categories: <a href="/category/oracle">oracle</a>, <a href="/category/sql">sql</a>)<li class="relatedPost"> <a href="https://lee-lindley.github.io/oracle/perl/2022/04/30/perl_dbd_oracle_clob.html">Using Perl DBD::Oracle to write LOB content</a> (Categories: <a href="/category/oracle">oracle</a>, <a href="/category/perl">perl</a>)<li class="relatedPost"> <a href="https://lee-lindley.github.io/oracle/plsql/sql/vim/2022/04/29/vim-plsql-syntax.html">Syntax Highlighting for PL/SQL in vim</a> (Categories: <a href="/category/oracle">oracle</a>, <a href="/category/plsql">plsql</a>, <a href="/category/sql">sql</a>, <a href="/category/vim">vim</a>)<li class="relatedPost"> <a href="https://lee-lindley.github.io/oracle/perl/linux/2022/04/28/Perl-DBD-Oracle-RHL.html">Installing Perl DBD::Oracle on RHL</a> (Categories: <a href="/category/oracle">oracle</a>, <a href="/category/perl">perl</a>, <a href="/category/linux">linux</a>)</ul></div><div class="PageNavigation"> <a class="prev" href="/oracle/perl/2022/04/30/perl_dbd_oracle_clob.html">&laquo; Using Perl DBD::Oracle to write LOB content</a> <a class="next" href="/oracle/sql/2022/10/09/antijoins_with_or.html">Tuning Query with OR Conditions in a NOT EXISTS &raquo;</a></div><div class="disqus-comments"><div id="disqus_thread"></div><script type="text/javascript"> /* <![CDATA[ */ var disqus_shortname = "leelindleyscratchpad"; var disqus_identifier = "https://lee-lindley.github.io_Manipulating XLSX Spreadsheets in PL/SQL"; var disqus_title = "Manipulating XLSX Spreadsheets in PL/SQL"; /* * * DON'T EDIT BELOW THIS LINE * * */ (function() { var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true; dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js'; (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq); })(); /* ]]> */ </script></div><footer> &copy; Lee Lindley - <a href="https://github.com/lee-lindley">https://github.com/lee-lindley</a> - Powered by Jekyll.<div class="btn-github" style="float:right;"> <iframe src="https://ghbtns.com/github-btn.html?user=agusmakmun&repo=agusmakmun.github.io&type=star&count=true" frameborder="0" scrolling="0" width="100" height="20px"></iframe> <iframe src="https://ghbtns.com/github-btn.html?user=agusmakmun&repo=agusmakmun.github.io&type=fork&count=true" frameborder="0" scrolling="0" width="100" height="20px"></iframe></div></footer></div></div><script src="//ajax.googleapis.com/ajax/libs/jquery/1.11.0/jquery.min.js"></script> <script src="//code.jquery.com/jquery-migrate-1.2.1.min.js"></script> <script src="/static/js/bootstrap.min.js"></script> <script src="/static/js/super-search.js"></script> <script src="/static/js/thickbox-compressed.js"></script> <script src="/static/js/projects.js"></script>
